{"ast":null,"code":"export const generateSortingSteps = (algorithm, arr) => {\n  switch (algorithm) {\n    case '선택 정렬':\n      return selectionSort([...arr]);\n    case '삽입 정렬':\n      return insertionSort([...arr]);\n    case '버블 정렬':\n      return bubbleSort([...arr]);\n    case '병합 정렬':\n      return mergeSort([...arr]);\n    case '힙 정렬':\n      return heapSort([...arr]);\n    case '퀵 정렬':\n      return quickSort([...arr]);\n    default:\n      return [];\n  }\n};\nconst selectionSort = arr => {\n  const steps = [];\n  const n = arr.length;\n  for (let i = 0; i < n - 1; i++) {\n    let minIdx = i;\n    steps.push({\n      array: [...arr],\n      description: `${i + 1}번째 패스: 인덱스 ${i}부터 최소값을 찾기 시작합니다.`,\n      variables: {\n        i,\n        minIdx\n      }\n    });\n    for (let j = i + 1; j < n; j++) {\n      if (arr[j] < arr[minIdx]) {\n        minIdx = j;\n        steps.push({\n          array: [...arr],\n          description: `새로운 최소값 ${arr[minIdx]}을(를) 인덱스 ${minIdx}에서 찾았습니다.`,\n          variables: {\n            i,\n            j,\n            minIdx\n          },\n          activeIndices: [i, j, minIdx]\n        });\n      }\n    }\n    if (minIdx !== i) {\n      [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];\n      steps.push({\n        array: [...arr],\n        description: `${arr[i]}과(와) ${arr[minIdx]}을(를) 교환했습니다.`,\n        variables: {\n          i,\n          minIdx\n        },\n        activeIndices: [i, minIdx]\n      });\n    } else {\n      steps.push({\n        array: [...arr],\n        description: `${arr[i]}이(가) 이미 올바른 위치에 있습니다.`,\n        variables: {\n          i,\n          minIdx\n        }\n      });\n    }\n  }\n  steps.push({\n    array: [...arr],\n    description: \"정렬이 완료되었습니다.\",\n    variables: {}\n  });\n  return steps;\n};\n\n// 다른 정렬 알고리즘들 (insertionSort, bubbleSort, mergeSort, heapSort, quickSort)도\n// 위와 같은 방식으로 구현해야 합니다. 각 알고리즘마다 적절한 단계와 설명을 포함해야 합니다.\n\n// 예시로 삽입 정렬의 구현을 보여드리겠습니다:\n\nconst insertionSort = arr => {\n  const steps = [];\n  const n = arr.length;\n  for (let i = 1; i < n; i++) {\n    let key = arr[i];\n    let j = i - 1;\n    steps.push({\n      array: [...arr],\n      description: `${i}번째 원소 ${key}를 정렬된 부분에 삽입하기 시작합니다.`,\n      variables: {\n        i,\n        key,\n        j\n      },\n      activeIndices: [i]\n    });\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j = j - 1;\n      steps.push({\n        array: [...arr],\n        description: `${arr[j + 1]}을(를) 오른쪽으로 이동시킵니다.`,\n        variables: {\n          i,\n          key,\n          j\n        },\n        activeIndices: [j, j + 1]\n      });\n    }\n    arr[j + 1] = key;\n    steps.push({\n      array: [...arr],\n      description: `${key}를 인덱스 ${j + 1}에 삽입했습니다.`,\n      variables: {\n        i,\n        key,\n        j\n      },\n      activeIndices: [j + 1]\n    });\n  }\n  steps.push({\n    array: [...arr],\n    description: \"정렬이 완료되었습니다.\",\n    variables: {}\n  });\n  return steps;\n};\n\n// 나머지 정렬 알고리즘들도 이와 유사한 방식으로 구현해야 합니다.","map":{"version":3,"names":["generateSortingSteps","algorithm","arr","selectionSort","insertionSort","bubbleSort","mergeSort","heapSort","quickSort","steps","n","length","i","minIdx","push","array","description","variables","j","activeIndices","key"],"sources":["/Users/kjunh972/project/jun/Spring/variousSorting/variousSorting/src/main/frontend/src/sortingAlgorithms.js"],"sourcesContent":["export const generateSortingSteps = (algorithm, arr) => {\n  switch (algorithm) {\n    case '선택 정렬':\n      return selectionSort([...arr]);\n    case '삽입 정렬':\n      return insertionSort([...arr]);\n    case '버블 정렬':\n      return bubbleSort([...arr]);\n    case '병합 정렬':\n      return mergeSort([...arr]);\n    case '힙 정렬':\n      return heapSort([...arr]);\n    case '퀵 정렬':\n      return quickSort([...arr]);\n    default:\n      return [];\n  }\n};\n\nconst selectionSort = (arr) => {\n  const steps = [];\n  const n = arr.length;\n\n  for (let i = 0; i < n - 1; i++) {\n    let minIdx = i;\n    steps.push({\n      array: [...arr],\n      description: `${i+1}번째 패스: 인덱스 ${i}부터 최소값을 찾기 시작합니다.`,\n      variables: { i, minIdx }\n    });\n\n    for (let j = i + 1; j < n; j++) {\n      if (arr[j] < arr[minIdx]) {\n        minIdx = j;\n        steps.push({\n          array: [...arr],\n          description: `새로운 최소값 ${arr[minIdx]}을(를) 인덱스 ${minIdx}에서 찾았습니다.`,\n          variables: { i, j, minIdx },\n          activeIndices: [i, j, minIdx]\n        });\n      }\n    }\n\n    if (minIdx !== i) {\n      [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];\n      steps.push({\n        array: [...arr],\n        description: `${arr[i]}과(와) ${arr[minIdx]}을(를) 교환했습니다.`,\n        variables: { i, minIdx },\n        activeIndices: [i, minIdx]\n      });\n    } else {\n      steps.push({\n        array: [...arr],\n        description: `${arr[i]}이(가) 이미 올바른 위치에 있습니다.`,\n        variables: { i, minIdx }\n      });\n    }\n  }\n\n  steps.push({\n    array: [...arr],\n    description: \"정렬이 완료되었습니다.\",\n    variables: {}\n  });\n\n  return steps;\n};\n\n// 다른 정렬 알고리즘들 (insertionSort, bubbleSort, mergeSort, heapSort, quickSort)도\n// 위와 같은 방식으로 구현해야 합니다. 각 알고리즘마다 적절한 단계와 설명을 포함해야 합니다.\n\n// 예시로 삽입 정렬의 구현을 보여드리겠습니다:\n\nconst insertionSort = (arr) => {\n  const steps = [];\n  const n = arr.length;\n\n  for (let i = 1; i < n; i++) {\n    let key = arr[i];\n    let j = i - 1;\n\n    steps.push({\n      array: [...arr],\n      description: `${i}번째 원소 ${key}를 정렬된 부분에 삽입하기 시작합니다.`,\n      variables: { i, key, j },\n      activeIndices: [i]\n    });\n\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j = j - 1;\n\n      steps.push({\n        array: [...arr],\n        description: `${arr[j+1]}을(를) 오른쪽으로 이동시킵니다.`,\n        variables: { i, key, j },\n        activeIndices: [j, j+1]\n      });\n    }\n\n    arr[j + 1] = key;\n    steps.push({\n      array: [...arr],\n      description: `${key}를 인덱스 ${j+1}에 삽입했습니다.`,\n      variables: { i, key, j },\n      activeIndices: [j+1]\n    });\n  }\n\n  steps.push({\n    array: [...arr],\n    description: \"정렬이 완료되었습니다.\",\n    variables: {}\n  });\n\n  return steps;\n};\n\n// 나머지 정렬 알고리즘들도 이와 유사한 방식으로 구현해야 합니다."],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}