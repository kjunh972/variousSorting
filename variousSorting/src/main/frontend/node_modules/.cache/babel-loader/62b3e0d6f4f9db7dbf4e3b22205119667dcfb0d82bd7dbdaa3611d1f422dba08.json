{"ast":null,"code":"export const generateSortingSteps = (algorithm, arr) => {\n  switch (algorithm) {\n    case '선택 정렬':\n      return selectionSort([...arr]);\n    case '삽입 정렬':\n      return insertionSort([...arr]);\n    case '버블 정렬':\n      return bubbleSort([...arr]);\n    case '병합 정렬':\n      return mergeSort([...arr]);\n    case '힙 정렬':\n      return heapSort([...arr]);\n    case '퀵 정렬':\n      return quickSort([...arr]);\n    case '트리 정렬':\n      return treeSort([...arr]);\n    case '팀 정렬':\n      return timSort([...arr]);\n    default:\n      return [];\n  }\n};\n\n// 선택 정렬\nconst selectionSort = arr => {\n  const steps = [];\n  const n = arr.length;\n  for (let i = 0; i < n - 1; i++) {\n    let minIdx = i;\n    steps.push({\n      array: [...arr],\n      description: `${i + 1}번째 패스: 인덱스 ${i}부터 최소값을 찾기 시작합니다.`,\n      variables: {\n        i,\n        minIdx\n      }\n    });\n    for (let j = i + 1; j < n; j++) {\n      if (arr[j] < arr[minIdx]) {\n        minIdx = j;\n        steps.push({\n          array: [...arr],\n          description: `새로운 최소값 ${arr[minIdx]}을(를) 인덱스 ${minIdx}에서 찾았습니다.`,\n          variables: {\n            i,\n            j,\n            minIdx\n          },\n          activeIndices: [i, j, minIdx]\n        });\n      }\n    }\n    if (minIdx !== i) {\n      [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];\n      steps.push({\n        array: [...arr],\n        description: `${arr[i]}과(와) ${arr[minIdx]}을(를) 교환했습니다.`,\n        variables: {\n          i,\n          minIdx\n        },\n        activeIndices: [i, minIdx]\n      });\n    } else {\n      steps.push({\n        array: [...arr],\n        description: `${arr[i]}이(가) 이미 올바른 위치에 있습니다.`,\n        variables: {\n          i,\n          minIdx\n        }\n      });\n    }\n  }\n  steps.push({\n    array: [...arr],\n    description: \"정렬이 완료되었습니다.\",\n    variables: {}\n  });\n  return steps;\n};\n\n// 삽입 정렬\nconst insertionSort = arr => {\n  const steps = [];\n  const n = arr.length;\n  for (let i = 1; i < n; i++) {\n    let key = arr[i];\n    let j = i - 1;\n    steps.push({\n      array: [...arr],\n      description: `${i}번째 원소 ${key}를 정렬된 부분에 삽입하기 시작합니다.`,\n      variables: {\n        i,\n        key,\n        j\n      },\n      activeIndices: [i]\n    });\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j = j - 1;\n      steps.push({\n        array: [...arr],\n        description: `${arr[j + 1]}을(를) 오른쪽으로 이동시킵니다.`,\n        variables: {\n          i,\n          key,\n          j\n        },\n        activeIndices: [j, j + 1]\n      });\n    }\n    arr[j + 1] = key;\n    steps.push({\n      array: [...arr],\n      description: `${key}를 인덱스 ${j + 1}에 삽입했습니다.`,\n      variables: {\n        i,\n        key,\n        j\n      },\n      activeIndices: [j + 1]\n    });\n  }\n  steps.push({\n    array: [...arr],\n    description: \"정렬이 완료되었습니다.\",\n    variables: {}\n  });\n  return steps;\n};\n\n// 버블 정렬\nconst bubbleSort = arr => {\n  const steps = [];\n  const n = arr.length;\n  for (let i = 0; i < n - 1; i++) {\n    let swapped = false;\n    steps.push({\n      array: [...arr],\n      description: `${i + 1}번째 패스를 시작합니다.`,\n      variables: {\n        i\n      }\n    });\n    for (let j = 0; j < n - i - 1; j++) {\n      steps.push({\n        array: [...arr],\n        description: `${arr[j]}와(과) ${arr[j + 1]}을(를) 비교합니다.`,\n        variables: {\n          i,\n          j\n        },\n        activeIndices: [j, j + 1]\n      });\n      if (arr[j] > arr[j + 1]) {\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n        swapped = true;\n        steps.push({\n          array: [...arr],\n          description: `${arr[j]}와(과) ${arr[j + 1]}을(를) 교환했습니다.`,\n          variables: {\n            i,\n            j\n          },\n          activeIndices: [j, j + 1]\n        });\n      }\n    }\n    if (!swapped) {\n      steps.push({\n        array: [...arr],\n        description: \"배열이 이미 정렬되어 있어 정렬을 종료합니다.\",\n        variables: {\n          i\n        }\n      });\n      break;\n    }\n  }\n  steps.push({\n    array: [...arr],\n    description: \"정렬이 완료되었습니다.\",\n    variables: {}\n  });\n  return steps;\n};\n\n// 병합 정렬\nconst mergeSort = arr => {\n  const steps = [];\n  const merge = (left, right, start) => {\n    let result = [];\n    let leftIndex = 0;\n    let rightIndex = 0;\n    while (leftIndex < left.length && rightIndex < right.length) {\n      if (left[leftIndex] < right[rightIndex]) {\n        result.push(left[leftIndex]);\n        leftIndex++;\n      } else {\n        result.push(right[rightIndex]);\n        rightIndex++;\n      }\n      steps.push({\n        array: [...arr.slice(0, start), ...result, ...left.slice(leftIndex), ...right.slice(rightIndex), ...arr.slice(start + left.length + right.length)],\n        description: `${result[result.length - 1]}을(를) 결과 배열에 추가했습니다.`,\n        variables: {\n          leftIndex,\n          rightIndex\n        },\n        activeIndices: [start + result.length - 1]\n      });\n    }\n    return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n  };\n  const mergeSortHelper = (arr, start = 0) => {\n    if (arr.length <= 1) return arr;\n    const mid = Math.floor(arr.length / 2);\n    const left = arr.slice(0, mid);\n    const right = arr.slice(mid);\n    steps.push({\n      array: [...arr],\n      description: `배열을 ${left}와(과) ${right} 두 부분으로 나눕니다.`,\n      variables: {\n        mid\n      },\n      activeIndices: [start, start + arr.length - 1]\n    });\n    return merge(mergeSortHelper(left, start), mergeSortHelper(right, start + mid), start);\n  };\n  const sorted = mergeSortHelper(arr);\n  arr.splice(0, arr.length, ...sorted);\n  steps.push({\n    array: [...arr],\n    description: \"정렬이 완료되었습니다.\",\n    variables: {}\n  });\n  return steps;\n};\n\n// 힙 정렬\nconst heapSort = arr => {\n  const steps = [];\n  const heapify = (n, i) => {\n    let largest = i;\n    const left = 2 * i + 1;\n    const right = 2 * i + 2;\n    steps.push({\n      array: [...arr],\n      description: `힙을 구성합니다. 현재 노드: ${arr[i]}, 왼쪽 자식: ${arr[left]}, 오른쪽 자식: ${arr[right]}`,\n      variables: {\n        i,\n        largest,\n        left,\n        right\n      },\n      activeIndices: [i, left, right].filter(idx => idx < n)\n    });\n    if (left < n && arr[left] > arr[largest]) {\n      largest = left;\n    }\n    if (right < n && arr[right] > arr[largest]) {\n      largest = right;\n    }\n    if (largest !== i) {\n      [arr[i], arr[largest]] = [arr[largest], arr[i]];\n      steps.push({\n        array: [...arr],\n        description: `${arr[i]}와(과) ${arr[largest]}을(를) 교환했습니다.`,\n        variables: {\n          i,\n          largest\n        },\n        activeIndices: [i, largest]\n      });\n      heapify(n, largest);\n    }\n  };\n  const n = arr.length;\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n    heapify(n, i);\n  }\n  for (let i = n - 1; i > 0; i--) {\n    [arr[0], arr[i]] = [arr[i], arr[0]];\n    steps.push({\n      array: [...arr],\n      description: `최대값 ${arr[i]}을(를) 배열의 끝으로 이동시킵니다.`,\n      variables: {\n        i\n      },\n      activeIndices: [0, i]\n    });\n    heapify(i, 0);\n  }\n  steps.push({\n    array: [...arr],\n    description: \"정렬이 완료되었습니다.\",\n    variables: {}\n  });\n  return steps;\n};\n\n// 퀵 정렬\nconst quickSort = arr => {\n  const steps = [];\n  const partition = (low, high) => {\n    const pivot = arr[high];\n    let i = low - 1;\n    steps.push({\n      array: [...arr],\n      description: `피벗으로 ${pivot}을(를) 선택했습니다.`,\n      variables: {\n        low,\n        high,\n        pivot\n      },\n      activeIndices: [high]\n    });\n    for (let j = low; j < high; j++) {\n      steps.push({\n        array: [...arr],\n        description: `${arr[j]}와(과) 피벗 ${pivot}을(를) 비교합니다.`,\n        variables: {\n          i,\n          j,\n          pivot\n        },\n        activeIndices: [j, high]\n      });\n      if (arr[j] < pivot) {\n        i++;\n        [arr[i], arr[j]] = [arr[j], arr[i]];\n        steps.push({\n          array: [...arr],\n          description: `${arr[i]}와(과) ${arr[j]}을(를) 교환했습니다.`,\n          variables: {\n            i,\n            j\n          },\n          activeIndices: [i, j]\n        });\n      }\n    }\n    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];\n    steps.push({\n      array: [...arr],\n      description: `피벗 ${pivot}을(를) 올바른 위치로 이동시켰습니다.`,\n      variables: {\n        i\n      },\n      activeIndices: [i + 1, high]\n    });\n    return i + 1;\n  };\n  const quickSortHelper = (low, high) => {\n    if (low < high) {\n      const pi = partition(low, high);\n      quickSortHelper(low, pi - 1);\n      quickSortHelper(pi + 1, high);\n    }\n  };\n  quickSortHelper(0, arr.length - 1);\n  steps.push({\n    array: [...arr],\n    description: \"정렬이 완료되었습니다.\",\n    variables: {}\n  });\n  return steps;\n};\n\n// 트리 정렬\nconst treeSort = arr => {\n  const steps = [];\n  class Node {\n    constructor(value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n    }\n  }\n  const insert = (root, value) => {\n    if (root === null) {\n      return new Node(value);\n    }\n    if (value < root.value) {\n      steps.push({\n        array: [...arr],\n        description: `${value}를 ${root.value}의 왼쪽에 삽입합니다.`,\n        variables: {\n          value,\n          root: root.value\n        }\n      });\n      root.left = insert(root.left, value);\n    } else {\n      steps.push({\n        array: [...arr],\n        description: `${value}를 ${root.value}의 오른쪽에 삽입합니다.`,\n        variables: {\n          value,\n          root: root.value\n        }\n      });\n      root.right = insert(root.right, value);\n    }\n    return root;\n  };\n  const inorderTraversal = (root, result) => {\n    if (root !== null) {\n      inorderTraversal(root.left, result);\n      result.push(root.value);\n      steps.push({\n        array: [...result, ...arr.slice(result.length)],\n        description: `${root.value}를 결과 배열에 추가합니다.`,\n        variables: {\n          current: root.value\n        }\n      });\n      inorderTraversal(root.right, result);\n    }\n  };\n  let root = null;\n  for (let i = 0; i < arr.length; i++) {\n    root = insert(root, arr[i]);\n  }\n  const result = [];\n  inorderTraversal(root, result);\n  steps.push({\n    array: [...result],\n    description: \"트리 정렬이 완료되었습니다.\",\n    variables: {}\n  });\n  return steps;\n};\n\n// 팀 정렬\nconst timSort = arr => {\n  const steps = [];\n  const RUN = 32;\n  const insertionSort = (arr, left, right) => {\n    for (let i = left + 1; i <= right; i++) {\n      let temp = arr[i];\n      let j = i - 1;\n      while (j >= left && arr[j] > temp) {\n        arr[j + 1] = arr[j];\n        j--;\n      }\n      arr[j + 1] = temp;\n      steps.push({\n        array: [...arr],\n        description: `${temp}를 인덱스 ${j + 1}에 삽입했습니다.`,\n        variables: {\n          left,\n          right,\n          i,\n          j,\n          temp\n        },\n        activeIndices: [j + 1]\n      });\n    }\n  };\n  const merge = (arr, l, m, r) => {\n    let len1 = m - l + 1,\n      len2 = r - m;\n    let left = new Array(len1),\n      right = new Array(len2);\n    for (let x = 0; x < len1; x++) {\n      left[x] = arr[l + x];\n    }\n    for (let x = 0; x < len2; x++) {\n      right[x] = arr[m + 1 + x];\n    }\n    let i = 0,\n      j = 0,\n      k = l;\n    while (i < len1 && j < len2) {\n      if (left[i] <= right[j]) {\n        arr[k] = left[i];\n        i++;\n      } else {\n        arr[k] = right[j];\n        j++;\n      }\n      steps.push({\n        array: [...arr],\n        description: `${arr[k]}를 병합된 배열에 추가했습니다.`,\n        variables: {\n          l,\n          m,\n          r,\n          i,\n          j,\n          k\n        },\n        activeIndices: [k]\n      });\n      k++;\n    }\n    while (i < len1) {\n      arr[k] = left[i];\n      steps.push({\n        array: [...arr],\n        description: `왼쪽 배열의 남은 요소 ${arr[k]}를 추가했습니다.`,\n        variables: {\n          k,\n          i\n        },\n        activeIndices: [k]\n      });\n      k++;\n      i++;\n    }\n    while (j < len2) {\n      arr[k] = right[j];\n      steps.push({\n        array: [...arr],\n        description: `오른쪽 배열의 남은 요소 ${arr[k]}를 추가했습니다.`,\n        variables: {\n          k,\n          j\n        },\n        activeIndices: [k]\n      });\n      k++;\n      j++;\n    }\n  };\n  for (let i = 0; i < arr.length; i += RUN) {\n    insertionSort(arr, i, Math.min(i + RUN - 1, arr.length - 1));\n  }\n  for (let size = RUN; size < arr.length; size = 2 * size) {\n    for (let start = 0; start < arr.length; start += 2 * size) {\n      let mid = start + size - 1;\n      let end = Math.min(start + 2 * size - 1, arr.length - 1);\n      if (mid < end) {\n        merge(arr, start, mid, end);\n      }\n    }\n  }\n  steps.push({\n    array: [...arr],\n    description: \"팀 정렬이 완료되었습니다.\",\n    variables: {}\n  });\n  return steps;\n};","map":{"version":3,"names":["generateSortingSteps","algorithm","arr","selectionSort","insertionSort","bubbleSort","mergeSort","heapSort","quickSort","treeSort","timSort","steps","n","length","i","minIdx","push","array","description","variables","j","activeIndices","key","swapped","merge","left","right","start","result","leftIndex","rightIndex","slice","concat","mergeSortHelper","mid","Math","floor","sorted","splice","heapify","largest","filter","idx","partition","low","high","pivot","quickSortHelper","pi","Node","constructor","value","insert","root","inorderTraversal","current","RUN","temp","l","m","r","len1","len2","Array","x","k","min","size","end"],"sources":["/Users/kjunh972/project/jun/Spring/variousSorting/variousSorting/src/main/frontend/src/sortingAlgorithms.js"],"sourcesContent":["export const generateSortingSteps = (algorithm, arr) => {\n  switch (algorithm) {\n    case '선택 정렬':\n      return selectionSort([...arr]);\n    case '삽입 정렬':\n      return insertionSort([...arr]);\n    case '버블 정렬':\n      return bubbleSort([...arr]);\n    case '병합 정렬':\n      return mergeSort([...arr]);\n    case '힙 정렬':\n      return heapSort([...arr]);\n    case '퀵 정렬':\n      return quickSort([...arr]);\n    case '트리 정렬':\n      return treeSort([...arr]);\n    case '팀 정렬':\n      return timSort([...arr]);\n    default:\n      return [];\n  }\n};\n\n// 선택 정렬\nconst selectionSort = (arr) => {\n  const steps = [];\n  const n = arr.length;\n\n  for (let i = 0; i < n - 1; i++) {\n    let minIdx = i;\n    steps.push({\n      array: [...arr],\n      description: `${i+1}번째 패스: 인덱스 ${i}부터 최소값을 찾기 시작합니다.`,\n      variables: { i, minIdx }\n    });\n\n    for (let j = i + 1; j < n; j++) {\n      if (arr[j] < arr[minIdx]) {\n        minIdx = j;\n        steps.push({\n          array: [...arr],\n          description: `새로운 최소값 ${arr[minIdx]}을(를) 인덱스 ${minIdx}에서 찾았습니다.`,\n          variables: { i, j, minIdx },\n          activeIndices: [i, j, minIdx]\n        });\n      }\n    }\n\n    if (minIdx !== i) {\n      [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];\n      steps.push({\n        array: [...arr],\n        description: `${arr[i]}과(와) ${arr[minIdx]}을(를) 교환했습니다.`,\n        variables: { i, minIdx },\n        activeIndices: [i, minIdx]\n      });\n    } else {\n      steps.push({\n        array: [...arr],\n        description: `${arr[i]}이(가) 이미 올바른 위치에 있습니다.`,\n        variables: { i, minIdx }\n      });\n    }\n  }\n\n  steps.push({\n    array: [...arr],\n    description: \"정렬이 완료되었습니다.\",\n    variables: {}\n  });\n\n  return steps;\n};\n\n// 삽입 정렬\nconst insertionSort = (arr) => {\n  const steps = [];\n  const n = arr.length;\n\n  for (let i = 1; i < n; i++) {\n    let key = arr[i];\n    let j = i - 1;\n\n    steps.push({\n      array: [...arr],\n      description: `${i}번째 원소 ${key}를 정렬된 부분에 삽입하기 시작합니다.`,\n      variables: { i, key, j },\n      activeIndices: [i]\n    });\n\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      j = j - 1;\n\n      steps.push({\n        array: [...arr],\n        description: `${arr[j+1]}을(를) 오른쪽으로 이동시킵니다.`,\n        variables: { i, key, j },\n        activeIndices: [j, j+1]\n      });\n    }\n\n    arr[j + 1] = key;\n    steps.push({\n      array: [...arr],\n      description: `${key}를 인덱스 ${j+1}에 삽입했습니다.`,\n      variables: { i, key, j },\n      activeIndices: [j+1]\n    });\n  }\n\n  steps.push({\n    array: [...arr],\n    description: \"정렬이 완료되었습니다.\",\n    variables: {}\n  });\n\n  return steps;\n};\n\n// 버블 정렬\nconst bubbleSort = (arr) => {\n  const steps = [];\n  const n = arr.length;\n\n  for (let i = 0; i < n - 1; i++) {\n    let swapped = false;\n\n    steps.push({\n      array: [...arr],\n      description: `${i+1}번째 패스를 시작합니다.`,\n      variables: { i }\n    });\n\n    for (let j = 0; j < n - i - 1; j++) {\n      steps.push({\n        array: [...arr],\n        description: `${arr[j]}와(과) ${arr[j+1]}을(를) 비교합니다.`,\n        variables: { i, j },\n        activeIndices: [j, j+1]\n      });\n\n      if (arr[j] > arr[j + 1]) {\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n        swapped = true;\n\n        steps.push({\n          array: [...arr],\n          description: `${arr[j]}와(과) ${arr[j+1]}을(를) 교환했습니다.`,\n          variables: { i, j },\n          activeIndices: [j, j+1]\n        });\n      }\n    }\n\n    if (!swapped) {\n      steps.push({\n        array: [...arr],\n        description: \"배열이 이미 정렬되어 있어 정렬을 종료합니다.\",\n        variables: { i }\n      });\n      break;\n    }\n  }\n\n  steps.push({\n    array: [...arr],\n    description: \"정렬이 완료되었습니다.\",\n    variables: {}\n  });\n\n  return steps;\n};\n\n// 병합 정렬\nconst mergeSort = (arr) => {\n  const steps = [];\n\n  const merge = (left, right, start) => {\n    let result = [];\n    let leftIndex = 0;\n    let rightIndex = 0;\n\n    while (leftIndex < left.length && rightIndex < right.length) {\n      if (left[leftIndex] < right[rightIndex]) {\n        result.push(left[leftIndex]);\n        leftIndex++;\n      } else {\n        result.push(right[rightIndex]);\n        rightIndex++;\n      }\n\n      steps.push({\n        array: [...arr.slice(0, start), ...result, ...left.slice(leftIndex), ...right.slice(rightIndex), ...arr.slice(start + left.length + right.length)],\n        description: `${result[result.length - 1]}을(를) 결과 배열에 추가했습니다.`,\n        variables: { leftIndex, rightIndex },\n        activeIndices: [start + result.length - 1]\n      });\n    }\n\n    return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n  };\n\n  const mergeSortHelper = (arr, start = 0) => {\n    if (arr.length <= 1) return arr;\n\n    const mid = Math.floor(arr.length / 2);\n    const left = arr.slice(0, mid);\n    const right = arr.slice(mid);\n\n    steps.push({\n      array: [...arr],\n      description: `배열을 ${left}와(과) ${right} 두 부분으로 나눕니다.`,\n      variables: { mid },\n      activeIndices: [start, start + arr.length - 1]\n    });\n\n    return merge(mergeSortHelper(left, start), mergeSortHelper(right, start + mid), start);\n  };\n\n  const sorted = mergeSortHelper(arr);\n  arr.splice(0, arr.length, ...sorted);\n\n  steps.push({\n    array: [...arr],\n    description: \"정렬이 완료되었습니다.\",\n    variables: {}\n  });\n\n  return steps;\n};\n\n// 힙 정렬\nconst heapSort = (arr) => {\n  const steps = [];\n\n  const heapify = (n, i) => {\n    let largest = i;\n    const left = 2 * i + 1;\n    const right = 2 * i + 2;\n\n    steps.push({\n      array: [...arr],\n      description: `힙을 구성합니다. 현재 노드: ${arr[i]}, 왼쪽 자식: ${arr[left]}, 오른쪽 자식: ${arr[right]}`,\n      variables: { i, largest, left, right },\n      activeIndices: [i, left, right].filter(idx => idx < n)\n    });\n\n    if (left < n && arr[left] > arr[largest]) {\n      largest = left;\n    }\n\n    if (right < n && arr[right] > arr[largest]) {\n      largest = right;\n    }\n\n    if (largest !== i) {\n      [arr[i], arr[largest]] = [arr[largest], arr[i]];\n\n      steps.push({\n        array: [...arr],\n        description: `${arr[i]}와(과) ${arr[largest]}을(를) 교환했습니다.`,\n        variables: { i, largest },\n        activeIndices: [i, largest]\n      });\n\n      heapify(n, largest);\n    }\n  };\n\n  const n = arr.length;\n\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n    heapify(n, i);\n  }\n\n  for (let i = n - 1; i > 0; i--) {\n    [arr[0], arr[i]] = [arr[i], arr[0]];\n\n    steps.push({\n      array: [...arr],\n      description: `최대값 ${arr[i]}을(를) 배열의 끝으로 이동시킵니다.`,\n      variables: { i },\n      activeIndices: [0, i]\n    });\n\n    heapify(i, 0);\n  }\n\n  steps.push({\n    array: [...arr],\n    description: \"정렬이 완료되었습니다.\",\n    variables: {}\n  });\n\n  return steps;\n};\n\n// 퀵 정렬\nconst quickSort = (arr) => {\n  const steps = [];\n\n  const partition = (low, high) => {\n    const pivot = arr[high];\n    let i = low - 1;\n\n    steps.push({\n      array: [...arr],\n      description: `피벗으로 ${pivot}을(를) 선택했습니다.`,\n      variables: { low, high, pivot },\n      activeIndices: [high]\n    });\n\n    for (let j = low; j < high; j++) {\n      steps.push({\n        array: [...arr],\n        description: `${arr[j]}와(과) 피벗 ${pivot}을(를) 비교합니다.`,\n        variables: { i, j, pivot },\n        activeIndices: [j, high]\n      });\n\n      if (arr[j] < pivot) {\n        i++;\n        [arr[i], arr[j]] = [arr[j], arr[i]];\n\n        steps.push({\n          array: [...arr],\n          description: `${arr[i]}와(과) ${arr[j]}을(를) 교환했습니다.`,\n          variables: { i, j },\n          activeIndices: [i, j]\n        });\n      }\n    }\n\n    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];\n\n    steps.push({\n      array: [...arr],\n      description: `피벗 ${pivot}을(를) 올바른 위치로 이동시켰습니다.`,\n      variables: { i },\n      activeIndices: [i + 1, high]\n    });\n\n    return i + 1;\n  };\n\n  const quickSortHelper = (low, high) => {\n    if (low < high) {\n      const pi = partition(low, high);\n\n      quickSortHelper(low, pi - 1);\n      quickSortHelper(pi + 1, high);\n    }\n  };\n\n  quickSortHelper(0, arr.length - 1);\n\n  steps.push({\n    array: [...arr],\n    description: \"정렬이 완료되었습니다.\",\n    variables: {}\n  });\n\n  return steps;\n};\n\n// 트리 정렬\nconst treeSort = (arr) => {\n  const steps = [];\n\n  class Node {\n    constructor(value) {\n      this.value = value;\n      this.left = null;\n      this.right = null;\n    }\n  }\n\n  const insert = (root, value) => {\n    if (root === null) {\n      return new Node(value);\n    }\n\n    if (value < root.value) {\n      steps.push({\n        array: [...arr],\n        description: `${value}를 ${root.value}의 왼쪽에 삽입합니다.`,\n        variables: { value, root: root.value },\n      });\n      root.left = insert(root.left, value);\n    } else {\n      steps.push({\n        array: [...arr],\n        description: `${value}를 ${root.value}의 오른쪽에 삽입합니다.`,\n        variables: { value, root: root.value },\n      });\n      root.right = insert(root.right, value);\n    }\n\n    return root;\n  };\n\n  const inorderTraversal = (root, result) => {\n    if (root !== null) {\n      inorderTraversal(root.left, result);\n      result.push(root.value);\n      steps.push({\n        array: [...result, ...arr.slice(result.length)],\n        description: `${root.value}를 결과 배열에 추가합니다.`,\n        variables: { current: root.value },\n      });\n      inorderTraversal(root.right, result);\n    }\n  };\n\n  let root = null;\n  for (let i = 0; i < arr.length; i++) {\n    root = insert(root, arr[i]);\n  }\n\n  const result = [];\n  inorderTraversal(root, result);\n\n  steps.push({\n    array: [...result],\n    description: \"트리 정렬이 완료되었습니다.\",\n    variables: {},\n  });\n\n  return steps;\n};\n\n// 팀 정렬\nconst timSort = (arr) => {\n  const steps = [];\n  const RUN = 32;\n\n  const insertionSort = (arr, left, right) => {\n    for (let i = left + 1; i <= right; i++) {\n      let temp = arr[i];\n      let j = i - 1;\n      while (j >= left && arr[j] > temp) {\n        arr[j + 1] = arr[j];\n        j--;\n      }\n      arr[j + 1] = temp;\n      steps.push({\n        array: [...arr],\n        description: `${temp}를 인덱스 ${j + 1}에 삽입했습니다.`,\n        variables: { left, right, i, j, temp },\n        activeIndices: [j + 1],\n      });\n    }\n  };\n\n  const merge = (arr, l, m, r) => {\n    let len1 = m - l + 1, len2 = r - m;\n    let left = new Array(len1), right = new Array(len2);\n    for (let x = 0; x < len1; x++) {\n      left[x] = arr[l + x];\n    }\n    for (let x = 0; x < len2; x++) {\n      right[x] = arr[m + 1 + x];\n    }\n\n    let i = 0, j = 0, k = l;\n\n    while (i < len1 && j < len2) {\n      if (left[i] <= right[j]) {\n        arr[k] = left[i];\n        i++;\n      } else {\n        arr[k] = right[j];\n        j++;\n      }\n      steps.push({\n        array: [...arr],\n        description: `${arr[k]}를 병합된 배열에 추가했습니다.`,\n        variables: { l, m, r, i, j, k },\n        activeIndices: [k],\n      });\n      k++;\n    }\n\n    while (i < len1) {\n      arr[k] = left[i];\n      steps.push({\n        array: [...arr],\n        description: `왼쪽 배열의 남은 요소 ${arr[k]}를 추가했습니다.`,\n        variables: { k, i },\n        activeIndices: [k],\n      });\n      k++;\n      i++;\n    }\n\n    while (j < len2) {\n      arr[k] = right[j];\n      steps.push({\n        array: [...arr],\n        description: `오른쪽 배열의 남은 요소 ${arr[k]}를 추가했습니다.`,\n        variables: { k, j },\n        activeIndices: [k],\n      });\n      k++;\n      j++;\n    }\n  };\n\n  for (let i = 0; i < arr.length; i += RUN) {\n    insertionSort(arr, i, Math.min((i + RUN - 1), (arr.length - 1)));\n  }\n\n  for (let size = RUN; size < arr.length; size = 2 * size) {\n    for (let start = 0; start < arr.length; start += 2 * size) {\n      let mid = start + size - 1;\n      let end = Math.min((start + 2 * size - 1), (arr.length - 1));\n\n      if (mid < end) {\n        merge(arr, start, mid, end);\n      }\n    }\n  }\n\n  steps.push({\n    array: [...arr],\n    description: \"팀 정렬이 완료되었습니다.\",\n    variables: {},\n  });\n\n  return steps;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}