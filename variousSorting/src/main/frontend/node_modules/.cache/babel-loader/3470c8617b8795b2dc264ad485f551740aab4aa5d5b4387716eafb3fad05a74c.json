{"ast":null,"code":"var _jsxFileName = \"/Users/kjunh972/project/jun/Spring/variousSorting/variousSorting/src/main/frontend/src/App.js\",\n  _s = $RefreshSig$();\nimport React, { useState, useEffect } from 'react';\nimport AlgorithmSelector from './AlgorithmSelector';\nimport SortingVisualizer from './SortingVisualizer';\nimport './App.css';\nimport { jsxDEV as _jsxDEV, Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst variableDescriptions = {\n  i: \"현재 기준 인덱스\",\n  j: \"비교 대상 인덱스\",\n  key: \"삽입할 현재 값\",\n  minIdx: \"현재까지의 최소값 인덱스\",\n  pivot: \"퀵정렬의 기준값\",\n  left: \"왼쪽 포인터\",\n  right: \"오른쪽 포인터\",\n  mid: \"중간 인덱스\",\n  temp: \"임시 저장 변수\",\n  len1: \"왼쪽 부분 배열의 길이\",\n  len2: \"오른쪽 부분 배열의 길이\",\n  k: \"병합 시 현재 위치\",\n  x: \"임시 인덱스\",\n  size: \"현재 부분 배열의 크기\",\n  start: \"현재 부분 배열의 시작 인덱스\",\n  end: \"현재 부분 배열의 끝 인덱스\",\n  RUN: \"팀정렬의 초기 런 크기\"\n};\nconst algorithmDescriptions = {\n  '선택 정렬': \"배열을 순회하면서 가장 작은 원소를 찾아 맨 앞으로 이동시키는 방식으로 정렬합니다.\",\n  '삽입 정렬': \"배열의 각 원소를 이미 정렬된 부분 배열의 적절한 위치에 삽입하여 정렬합니다.\",\n  '버블 정렬': \"인접한 두 원소를 비교하여 큰 값을 뒤로 보내는 과정을 반복하여 정렬합니다.\",\n  '병합 정렬': \"배열을 반으로 나누고, 각 부분을 정렬한 후 병합하는 과정을 재귀적으로 수행합니다.\",\n  '힙 정렬': \"배열을 최대 힙으로 구성한 후, 루트 노드와 마지막 노드를 교환하며 정렬합니다.\",\n  '퀵 정렬': \"피벗을 선택하고 피벗보다 작은 값과 큰 값을 분할한 후, 각 부분을 재귀적으로 정렬합니다.\",\n  '트리 정렬': \"이진 탐색 트리를 구성하고 중위 순회하여 정렬된 결과를 얻습니다.\",\n  '팀 정렬': \"작은 부분 배열에는 삽입 정렬을, 큰 부분 배열에는 병합 정렬을 사용하는 하이브리드 정렬 알고리즘입니다.\"\n};\nconst App = () => {\n  _s();\n  const [selectedAlgorithm, setSelectedAlgorithm] = useState('');\n  const [showPopup, setShowPopup] = useState(true);\n  const [sortingSteps, setSortingSteps] = useState([]);\n  const [currentStep, setCurrentStep] = useState(0);\n  const [numbers, setNumbers] = useState([]);\n  useEffect(() => {\n    if (selectedAlgorithm && numbers.length > 0) {\n      const steps = generateSortingSteps(selectedAlgorithm, [...numbers]);\n      setSortingSteps(steps);\n      setCurrentStep(0);\n    }\n  }, [selectedAlgorithm, numbers]);\n  const generateSortingSteps = (algorithm, arr) => {\n    switch (algorithm) {\n      case '선택 정렬':\n        return selectionSort(arr);\n      case '삽입 정렬':\n        return insertionSort(arr);\n      case '버블 정렬':\n        return bubbleSort(arr);\n      case '병합 정렬':\n        return mergeSort(arr);\n      case '힙 정렬':\n        return heapSort(arr);\n      case '퀵 정렬':\n        return quickSort(arr);\n      case '트리 정렬':\n        return treeSort(arr);\n      case '팀 정렬':\n        return timSort(arr);\n      default:\n        return [];\n    }\n  };\n  const addNumber = num => {\n    setNumbers(prev => [...prev, num]);\n  };\n  const addRandomNumber = () => {\n    const randomNum = Math.floor(Math.random() * 100) + 1;\n    addNumber(randomNum);\n  };\n  const removeNumber = index => {\n    setNumbers(prev => prev.filter((_, i) => i !== index));\n  };\n  const resetAlgorithm = () => {\n    setShowPopup(true);\n    setSelectedAlgorithm('');\n    setSortingSteps([]);\n    setCurrentStep(0);\n  };\n  return /*#__PURE__*/_jsxDEV(\"div\", {\n    className: \"app\",\n    children: [showPopup && /*#__PURE__*/_jsxDEV(AlgorithmSelector, {\n      onSelect: algorithm => {\n        setSelectedAlgorithm(algorithm);\n        setShowPopup(false);\n      }\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 89,\n      columnNumber: 9\n    }, this), !showPopup && /*#__PURE__*/_jsxDEV(_Fragment, {\n      children: [/*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"number-input\",\n        children: [/*#__PURE__*/_jsxDEV(\"input\", {\n          type: \"number\",\n          placeholder: \"\\uC22B\\uC790 \\uC785\\uB825\",\n          onKeyPress: e => {\n            if (e.key === 'Enter') {\n              addNumber(parseInt(e.target.value));\n              e.target.value = '';\n            }\n          }\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 99,\n          columnNumber: 13\n        }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n          onClick: addRandomNumber,\n          children: \"\\uB79C\\uB364 \\uC22B\\uC790 \\uCD94\\uAC00\"\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 109,\n          columnNumber: 13\n        }, this)]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 98,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"div\", {\n        className: \"current-numbers\",\n        children: [\"\\uD604\\uC7AC \\uC22B\\uC790:\", numbers.map((num, index) => /*#__PURE__*/_jsxDEV(\"span\", {\n          className: \"number-tag\",\n          children: [num, /*#__PURE__*/_jsxDEV(\"button\", {\n            onClick: () => removeNumber(index),\n            children: \"\\xD7\"\n          }, void 0, false, {\n            fileName: _jsxFileName,\n            lineNumber: 116,\n            columnNumber: 17\n          }, this)]\n        }, index, true, {\n          fileName: _jsxFileName,\n          lineNumber: 114,\n          columnNumber: 15\n        }, this))]\n      }, void 0, true, {\n        fileName: _jsxFileName,\n        lineNumber: 111,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(SortingVisualizer, {\n        algorithm: selectedAlgorithm,\n        steps: sortingSteps,\n        currentStep: currentStep,\n        setCurrentStep: setCurrentStep\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 120,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(\"button\", {\n        className: \"reset-button\",\n        onClick: resetAlgorithm,\n        children: \"\\uC815\\uB82C \\uB2E4\\uC2DC \\uC120\\uD0DD\"\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 126,\n        columnNumber: 11\n      }, this)]\n    }, void 0, true)]\n  }, void 0, true, {\n    fileName: _jsxFileName,\n    lineNumber: 87,\n    columnNumber: 5\n  }, this);\n};\n_s(App, \"SjlfQ0xDGYJs0Di2zkAZgd7Y5Jo=\");\n_c = App;\nconst selectionSort = arr => {\n  const steps = [];\n  const n = arr.length;\n  for (let i = 0; i < n - 1; i++) {\n    let minIdx = i;\n    steps.push({\n      array: [...arr],\n      activeIndices: [i],\n      variables: {\n        i,\n        minIdx\n      },\n      description: `현재 인덱스 i=${i}에서 시작합니다. 최소값의 인덱스 minIdx=${minIdx}로 초기화합니다.`\n    });\n    for (let j = i + 1; j < n; j++) {\n      steps.push({\n        array: [...arr],\n        activeIndices: [minIdx, j],\n        variables: {\n          i,\n          j,\n          minIdx\n        },\n        description: `현재 값 arr[${j}]=${arr[j]}와 최소값 arr[${minIdx}]=${arr[minIdx]}를 비교합니다.`\n      });\n      if (arr[j] < arr[minIdx]) {\n        minIdx = j;\n        steps.push({\n          array: [...arr],\n          activeIndices: [minIdx],\n          variables: {\n            i,\n            j,\n            minIdx\n          },\n          description: `새로운 최소값을 찾았습니다. minIdx를 ${j}로 업데이트합니다.`\n        });\n      }\n    }\n    if (minIdx !== i) {\n      [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];\n      steps.push({\n        array: [...arr],\n        activeIndices: [i, minIdx],\n        variables: {\n          i,\n          minIdx\n        },\n        description: `arr[${i}]와 arr[${minIdx}]의 위치를 교환합니다.`\n      });\n    }\n  }\n  steps.push({\n    array: [...arr],\n    activeIndices: [],\n    variables: {},\n    description: '정렬이 완료되었습니다.'\n  });\n  return steps;\n};\nconst insertionSort = arr => {\n  const steps = [];\n  const n = arr.length;\n  for (let i = 1; i < n; i++) {\n    let key = arr[i];\n    let j = i - 1;\n    steps.push({\n      array: [...arr],\n      activeIndices: [i],\n      variables: {\n        i,\n        key,\n        j\n      },\n      description: `현재 키 값 key=${key}를 선택합니다. j=${j}부터 비교를 시작합니다.`\n    });\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      steps.push({\n        array: [...arr],\n        activeIndices: [j, j + 1],\n        variables: {\n          i,\n          key,\n          j\n        },\n        description: `arr[${j}]=${arr[j]}를 오른쪽으로 이동합니다.`\n      });\n      j--;\n    }\n    arr[j + 1] = key;\n    steps.push({\n      array: [...arr],\n      activeIndices: [j + 1],\n      variables: {\n        i,\n        key,\n        j\n      },\n      description: `key=${key}를 arr[${j + 1}]에 삽입합니다.`\n    });\n  }\n  steps.push({\n    array: [...arr],\n    activeIndices: [],\n    variables: {},\n    description: '정렬이 완료되었습니다.'\n  });\n  return steps;\n};\nconst bubbleSort = arr => {\n  const steps = [];\n  const n = arr.length;\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = 0; j < n - i - 1; j++) {\n      steps.push({\n        array: [...arr],\n        activeIndices: [j, j + 1],\n        variables: {\n          i,\n          j\n        },\n        description: `arr[${j}]=${arr[j]}와 arr[${j + 1}]=${arr[j + 1]}를 비교합니다.`\n      });\n      if (arr[j] > arr[j + 1]) {\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n        steps.push({\n          array: [...arr],\n          activeIndices: [j, j + 1],\n          variables: {\n            i,\n            j\n          },\n          description: `arr[${j}]와 arr[${j + 1}]의 위치를 교환합니다.`\n        });\n      }\n    }\n  }\n  steps.push({\n    array: [...arr],\n    activeIndices: [],\n    variables: {},\n    description: '정렬이 완료되었습니다.'\n  });\n  return steps;\n};\nconst mergeSort = arr => {\n  const steps = [];\n  const merge = (left, right) => {\n    let result = [];\n    let leftIndex = 0;\n    let rightIndex = 0;\n    while (leftIndex < left.length && rightIndex < right.length) {\n      if (left[leftIndex] < right[rightIndex]) {\n        result.push(left[leftIndex]);\n        leftIndex++;\n      } else {\n        result.push(right[rightIndex]);\n        rightIndex++;\n      }\n      steps.push({\n        array: [...arr.slice(0, leftIndex + rightIndex), ...result, ...left.slice(leftIndex), ...right.slice(rightIndex)],\n        activeIndices: [leftIndex + rightIndex],\n        variables: {\n          leftIndex,\n          rightIndex\n        },\n        description: `${result[result.length - 1]}을 결과 배열에 추가합니다.`\n      });\n    }\n    return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n  };\n  const mergeSortRecursive = arr => {\n    if (arr.length <= 1) return arr;\n    const mid = Math.floor(arr.length / 2);\n    const left = arr.slice(0, mid);\n    const right = arr.slice(mid);\n    steps.push({\n      array: [...arr],\n      activeIndices: [],\n      variables: {\n        mid\n      },\n      description: `배열을 ${mid} 인덱스를 기준으로 분할합니다.`\n    });\n    return merge(mergeSortRecursive(left), mergeSortRecursive(right));\n  };\n  const sorted = mergeSortRecursive(arr);\n  arr.splice(0, arr.length, ...sorted);\n  steps.push({\n    array: [...arr],\n    activeIndices: [],\n    variables: {},\n    description: '정렬이 완료되었습니다.'\n  });\n  return steps;\n};\nconst heapSort = arr => {\n  const steps = [];\n  const heapify = (n, i) => {\n    let largest = i;\n    const left = 2 * i + 1;\n    const right = 2 * i + 2;\n    if (left < n && arr[left] > arr[largest]) {\n      largest = left;\n    }\n    if (right < n && arr[right] > arr[largest]) {\n      largest = right;\n    }\n    if (largest !== i) {\n      steps.push({\n        array: [...arr],\n        activeIndices: [i, largest],\n        variables: {\n          i,\n          largest\n        },\n        description: `arr[${i}]=${arr[i]}와 arr[${largest}]=${arr[largest]}의 위치를 교환합니다.`\n      });\n      [arr[i], arr[largest]] = [arr[largest], arr[i]];\n      heapify(n, largest);\n    }\n  };\n  const n = arr.length;\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n    heapify(n, i);\n  }\n  for (let i = n - 1; i > 0; i--) {\n    steps.push({\n      array: [...arr],\n      activeIndices: [0, i],\n      variables: {\n        i\n      },\n      description: `루트 노드 arr[0]=${arr[0]}를 마지막 요소 arr[${i}]=${arr[i]}와 교환합니다.`\n    });\n    [arr[0], arr[i]] = [arr[i], arr[0]];\n    heapify(i, 0);\n  }\n  steps.push({\n    array: [...arr],\n    activeIndices: [],\n    variables: {},\n    description: '정렬이 완료되었습니다.'\n  });\n  return steps;\n};\nconst quickSort = arr => {\n  const steps = [];\n  const partition = (low, high) => {\n    const pivot = arr[high];\n    let i = low - 1;\n    steps.push({\n      array: [...arr],\n      activeIndices: [high],\n      variables: {\n        pivot,\n        low,\n        high\n      },\n      description: `피벗을 arr[${high}]=${pivot}로 선택합니다.`\n    });\n    for (let j = low; j < high; j++) {\n      steps.push({\n        array: [...arr],\n        activeIndices: [j, high],\n        variables: {\n          pivot,\n          i,\n          j\n        },\n        description: `arr[${j}]=${arr[j]}를 피벗 ${pivot}과 비교합니다.`\n      });\n      if (arr[j] < pivot) {\n        i++;\n        [arr[i], arr[j]] = [arr[j], arr[i]];\n        steps.push({\n          array: [...arr],\n          activeIndices: [i, j],\n          variables: {\n            pivot,\n            i,\n            j\n          },\n          description: `arr[${i}]=${arr[i]}와 arr[${j}]=${arr[j]}의 위치를 교환합니다.`\n        });\n      }\n    }\n    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];\n    steps.push({\n      array: [...arr],\n      activeIndices: [i + 1, high],\n      variables: {\n        pivot,\n        i\n      },\n      description: `피벗을 올바른 위치로 이동합니다.`\n    });\n    return i + 1;\n  };\n  const quickSortRecursive = (low, high) => {\n    if (low < high) {\n      const pi = partition(low, high);\n      quickSortRecursive(low, pi - 1);\n      quickSortRecursive(pi + 1, high);\n    }\n  };\n  quickSortRecursive(0, arr.length - 1);\n  steps.push({\n    array: [...arr],\n    activeIndices: [],\n    variables: {},\n    description: '정렬이 완료되었습니다.'\n  });\n  return steps;\n};\nconst treeSort = arr => {\n  const steps = [];\n  class Node {\n    constructor(data) {\n      this.data = data;\n      this.left = null;\n      this.right = null;\n    }\n  }\n  const insert = (root, key) => {\n    if (root === null) {\n      root = new Node(key);\n      steps.push({\n        array: [...arr],\n        activeIndices: [arr.indexOf(key)],\n        variables: {\n          key\n        },\n        description: `${key}를 트리에 삽입합니다.`\n      });\n      return root;\n    }\n    if (key < root.data) {\n      root.left = insert(root.left, key);\n    } else if (key > root.data) {\n      root.right = insert(root.right, key);\n    }\n    return root;\n  };\n  const inorderTraversal = (root, result) => {\n    if (root !== null) {\n      inorderTraversal(root.left, result);\n      result.push(root.data);\n      steps.push({\n        array: [...result, ...arr.slice(result.length)],\n        activeIndices: [result.length - 1],\n        variables: {\n          current: root.data\n        },\n        description: `${root.data}를 결과 배열에 추가합니다.`\n      });\n      inorderTraversal(root.right, result);\n    }\n  };\n  let root = null;\n  for (let i = 0; i < arr.length; i++) {\n    root = insert(root, arr[i]);\n  }\n  const sortedArr = [];\n  inorderTraversal(root, sortedArr);\n  arr.splice(0, arr.length, ...sortedArr);\n  steps.push({\n    array: [...arr],\n    activeIndices: [],\n    variables: {},\n    description: '정렬이 완료되었습니다.'\n  });\n  return steps;\n};\nconst timSort = arr => {\n  const steps = [];\n  const RUN = 32;\n  const n = arr.length;\n  const insertionSort = (arr, left, right) => {\n    for (let i = left + 1; i <= right; i++) {\n      const temp = arr[i];\n      let j = i - 1;\n      while (j >= left && arr[j] > temp) {\n        arr[j + 1] = arr[j];\n        j--;\n      }\n      arr[j + 1] = temp;\n      steps.push({\n        array: [...arr],\n        activeIndices: [j + 1],\n        variables: {\n          i,\n          j,\n          temp\n        },\n        description: `${temp}를 ${j + 2}번째 위치에 삽입했습니다.`\n      });\n    }\n  };\n  const merge = (arr, l, m, r) => {\n    const len1 = m - l + 1,\n      len2 = r - m;\n    const left = new Array(len1),\n      right = new Array(len2);\n    for (let x = 0; x < len1; x++) {\n      left[x] = arr[l + x];\n    }\n    for (let x = 0; x < len2; x++) {\n      right[x] = arr[m + 1 + x];\n    }\n    let i = 0,\n      j = 0,\n      k = l;\n    while (i < len1 && j < len2) {\n      if (left[i] <= right[j]) {\n        arr[k] = left[i];\n        i++;\n      } else {\n        arr[k] = right[j];\n        j++;\n      }\n      steps.push({\n        array: [...arr],\n        activeIndices: [k],\n        variables: {\n          i,\n          j,\n          k\n        },\n        description: `${arr[k]}를 ${k + 1}번째 위치에 병합했습니다.`\n      });\n      k++;\n    }\n    while (i < len1) {\n      arr[k] = left[i];\n      steps.push({\n        array: [...arr],\n        activeIndices: [k],\n        variables: {\n          i,\n          k\n        },\n        description: `${arr[k]}를 ${k + 1}번째 위치에 병합했습니다.`\n      });\n      i++;\n      k++;\n    }\n    while (j < len2) {\n      arr[k] = right[j];\n      steps.push({\n        array: [...arr],\n        activeIndices: [k],\n        variables: {\n          j,\n          k\n        },\n        description: `${arr[k]}를 ${k + 1}번째 위치에 병합했습니다.`\n      });\n      j++;\n      k++;\n    }\n  };\n  for (let i = 0; i < n; i += RUN) {\n    insertionSort(arr, i, Math.min(i + RUN - 1, n - 1));\n  }\n  for (let size = RUN; size < n; size = 2 * size) {\n    for (let start = 0; start < n; start += 2 * size) {\n      const mid = start + size - 1;\n      const end = Math.min(start + 2 * size - 1, n - 1);\n      merge(arr, start, mid, end);\n    }\n  }\n  steps.push({\n    array: [...arr],\n    activeIndices: [],\n    variables: {},\n    description: '정렬이 완료되었습니다.'\n  });\n  return steps;\n};\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["React","useState","useEffect","AlgorithmSelector","SortingVisualizer","jsxDEV","_jsxDEV","Fragment","_Fragment","variableDescriptions","i","j","key","minIdx","pivot","left","right","mid","temp","len1","len2","k","x","size","start","end","RUN","algorithmDescriptions","App","_s","selectedAlgorithm","setSelectedAlgorithm","showPopup","setShowPopup","sortingSteps","setSortingSteps","currentStep","setCurrentStep","numbers","setNumbers","length","steps","generateSortingSteps","algorithm","arr","selectionSort","insertionSort","bubbleSort","mergeSort","heapSort","quickSort","treeSort","timSort","addNumber","num","prev","addRandomNumber","randomNum","Math","floor","random","removeNumber","index","filter","_","resetAlgorithm","className","children","onSelect","fileName","_jsxFileName","lineNumber","columnNumber","type","placeholder","onKeyPress","e","parseInt","target","value","onClick","map","_c","n","push","array","activeIndices","variables","description","merge","result","leftIndex","rightIndex","slice","concat","mergeSortRecursive","sorted","splice","heapify","largest","partition","low","high","quickSortRecursive","pi","Node","constructor","data","insert","root","indexOf","inorderTraversal","current","sortedArr","l","m","r","Array","min","$RefreshReg$"],"sources":["/Users/kjunh972/project/jun/Spring/variousSorting/variousSorting/src/main/frontend/src/App.js"],"sourcesContent":["import React, { useState, useEffect } from 'react';\nimport AlgorithmSelector from './AlgorithmSelector';\nimport SortingVisualizer from './SortingVisualizer';\nimport './App.css';\n\nconst variableDescriptions = {\n  i: \"현재 기준 인덱스\",\n  j: \"비교 대상 인덱스\",\n  key: \"삽입할 현재 값\",\n  minIdx: \"현재까지의 최소값 인덱스\",\n  pivot: \"퀵정렬의 기준값\",\n  left: \"왼쪽 포인터\",\n  right: \"오른쪽 포인터\",\n  mid: \"중간 인덱스\",\n  temp: \"임시 저장 변수\",\n  len1: \"왼쪽 부분 배열의 길이\",\n  len2: \"오른쪽 부분 배열의 길이\",\n  k: \"병합 시 현재 위치\",\n  x: \"임시 인덱스\",\n  size: \"현재 부분 배열의 크기\",\n  start: \"현재 부분 배열의 시작 인덱스\",\n  end: \"현재 부분 배열의 끝 인덱스\",\n  RUN: \"팀정렬의 초기 런 크기\"\n};\n\nconst algorithmDescriptions = {\n  '선택 정렬': \"배열을 순회하면서 가장 작은 원소를 찾아 맨 앞으로 이동시키는 방식으로 정렬합니다.\",\n  '삽입 정렬': \"배열의 각 원소를 이미 정렬된 부분 배열의 적절한 위치에 삽입하여 정렬합니다.\",\n  '버블 정렬': \"인접한 두 원소를 비교하여 큰 값을 뒤로 보내는 과정을 반복하여 정렬합니다.\",\n  '병합 정렬': \"배열을 반으로 나누고, 각 부분을 정렬한 후 병합하는 과정을 재귀적으로 수행합니다.\",\n  '힙 정렬': \"배열을 최대 힙으로 구성한 후, 루트 노드와 마지막 노드를 교환하며 정렬합니다.\",\n  '퀵 정렬': \"피벗을 선택하고 피벗보다 작은 값과 큰 값을 분할한 후, 각 부분을 재귀적으로 정렬합니다.\",\n  '트리 정렬': \"이진 탐색 트리를 구성하고 중위 순회하여 정렬된 결과를 얻습니다.\",\n  '팀 정렬': \"작은 부분 배열에는 삽입 정렬을, 큰 부분 배열에는 병합 정렬을 사용하는 하이브리드 정렬 알고리즘입니다.\"\n};\n\nconst App = () => {\n  const [selectedAlgorithm, setSelectedAlgorithm] = useState('');\n  const [showPopup, setShowPopup] = useState(true);\n  const [sortingSteps, setSortingSteps] = useState([]);\n  const [currentStep, setCurrentStep] = useState(0);\n  const [numbers, setNumbers] = useState([]);\n\n  useEffect(() => {\n    if (selectedAlgorithm && numbers.length > 0) {\n      const steps = generateSortingSteps(selectedAlgorithm, [...numbers]);\n      setSortingSteps(steps);\n      setCurrentStep(0);\n    }\n  }, [selectedAlgorithm, numbers]);\n\n  const generateSortingSteps = (algorithm, arr) => {\n    switch (algorithm) {\n      case '선택 정렬': return selectionSort(arr);\n      case '삽입 정렬': return insertionSort(arr);\n      case '버블 정렬': return bubbleSort(arr);\n      case '병합 정렬': return mergeSort(arr);\n      case '힙 정렬': return heapSort(arr);\n      case '퀵 정렬': return quickSort(arr);\n      case '트리 정렬': return treeSort(arr);\n      case '팀 정렬': return timSort(arr);\n      default: return [];\n    }\n  };\n\n  const addNumber = (num) => {\n    setNumbers(prev => [...prev, num]);\n  };\n\n  const addRandomNumber = () => {\n    const randomNum = Math.floor(Math.random() * 100) + 1;\n    addNumber(randomNum);\n  };\n\n  const removeNumber = (index) => {\n    setNumbers(prev => prev.filter((_, i) => i !== index));\n  };\n\n  const resetAlgorithm = () => {\n    setShowPopup(true);\n    setSelectedAlgorithm('');\n    setSortingSteps([]);\n    setCurrentStep(0);\n  };\n\n  return (\n    <div className=\"app\">\n      {showPopup && (\n        <AlgorithmSelector\n          onSelect={(algorithm) => {\n            setSelectedAlgorithm(algorithm);\n            setShowPopup(false);\n          }}\n        />\n      )}\n      {!showPopup && (\n        <>\n          <div className=\"number-input\">\n            <input\n              type=\"number\"\n              placeholder=\"숫자 입력\"\n              onKeyPress={(e) => {\n                if (e.key === 'Enter') {\n                  addNumber(parseInt(e.target.value));\n                  e.target.value = '';\n                }\n              }}\n            />\n            <button onClick={addRandomNumber}>랜덤 숫자 추가</button>\n          </div>\n          <div className=\"current-numbers\">\n            현재 숫자:\n            {numbers.map((num, index) => (\n              <span key={index} className=\"number-tag\">\n                {num}\n                <button onClick={() => removeNumber(index)}>×</button>\n              </span>\n            ))}\n          </div>\n          <SortingVisualizer\n            algorithm={selectedAlgorithm}\n            steps={sortingSteps}\n            currentStep={currentStep}\n            setCurrentStep={setCurrentStep}\n          />\n          <button className=\"reset-button\" onClick={resetAlgorithm}>정렬 다시 선택</button>\n        </>\n      )}\n    </div>\n  );\n};\n\nconst selectionSort = (arr) => {\n  const steps = [];\n  const n = arr.length;\n\n  for (let i = 0; i < n - 1; i++) {\n    let minIdx = i;\n    steps.push({\n      array: [...arr],\n      activeIndices: [i],\n      variables: { i, minIdx },\n      description: `현재 인덱스 i=${i}에서 시작합니다. 최소값의 인덱스 minIdx=${minIdx}로 초기화합니다.`\n    });\n\n    for (let j = i + 1; j < n; j++) {\n      steps.push({\n        array: [...arr],\n        activeIndices: [minIdx, j],\n        variables: { i, j, minIdx },\n        description: `현재 값 arr[${j}]=${arr[j]}와 최소값 arr[${minIdx}]=${arr[minIdx]}를 비교합니다.`\n      });\n\n      if (arr[j] < arr[minIdx]) {\n        minIdx = j;\n        steps.push({\n          array: [...arr],\n          activeIndices: [minIdx],\n          variables: { i, j, minIdx },\n          description: `새로운 최소값을 찾았습니다. minIdx를 ${j}로 업데이트합니다.`\n        });\n      }\n    }\n\n    if (minIdx !== i) {\n      [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];\n      steps.push({\n        array: [...arr],\n        activeIndices: [i, minIdx],\n        variables: { i, minIdx },\n        description: `arr[${i}]와 arr[${minIdx}]의 위치를 교환합니다.`\n      });\n    }\n  }\n\n  steps.push({\n    array: [...arr],\n    activeIndices: [],\n    variables: {},\n    description: '정렬이 완료되었습니다.'\n  });\n\n  return steps;\n};\n\nconst insertionSort = (arr) => {\n  const steps = [];\n  const n = arr.length;\n\n  for (let i = 1; i < n; i++) {\n    let key = arr[i];\n    let j = i - 1;\n\n    steps.push({\n      array: [...arr],\n      activeIndices: [i],\n      variables: { i, key, j },\n      description: `현재 키 값 key=${key}를 선택합니다. j=${j}부터 비교를 시작합니다.`\n    });\n\n    while (j >= 0 && arr[j] > key) {\n      arr[j + 1] = arr[j];\n      steps.push({\n        array: [...arr],\n        activeIndices: [j, j + 1],\n        variables: { i, key, j },\n        description: `arr[${j}]=${arr[j]}를 오른쪽으로 이동합니다.`\n      });\n      j--;\n    }\n\n    arr[j + 1] = key;\n    steps.push({\n      array: [...arr],\n      activeIndices: [j + 1],\n      variables: { i, key, j },\n      description: `key=${key}를 arr[${j + 1}]에 삽입합니다.`\n    });\n  }\n\n  steps.push({\n    array: [...arr],\n    activeIndices: [],\n    variables: {},\n    description: '정렬이 완료되었습니다.'\n  });\n\n  return steps;\n};\n\nconst bubbleSort = (arr) => {\n  const steps = [];\n  const n = arr.length;\n\n  for (let i = 0; i < n - 1; i++) {\n    for (let j = 0; j < n - i - 1; j++) {\n      steps.push({\n        array: [...arr],\n        activeIndices: [j, j + 1],\n        variables: { i, j },\n        description: `arr[${j}]=${arr[j]}와 arr[${j + 1}]=${arr[j + 1]}를 비교합니다.`\n      });\n\n      if (arr[j] > arr[j + 1]) {\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n        steps.push({\n          array: [...arr],\n          activeIndices: [j, j + 1],\n          variables: { i, j },\n          description: `arr[${j}]와 arr[${j + 1}]의 위치를 교환합니다.`\n        });\n      }\n    }\n  }\n\n  steps.push({\n    array: [...arr],\n    activeIndices: [],\n    variables: {},\n    description: '정렬이 완료되었습니다.'\n  });\n\n  return steps;\n};\n\nconst mergeSort = (arr) => {\n  const steps = [];\n\n  const merge = (left, right) => {\n    let result = [];\n    let leftIndex = 0;\n    let rightIndex = 0;\n\n    while (leftIndex < left.length && rightIndex < right.length) {\n      if (left[leftIndex] < right[rightIndex]) {\n        result.push(left[leftIndex]);\n        leftIndex++;\n      } else {\n        result.push(right[rightIndex]);\n        rightIndex++;\n      }\n      steps.push({\n        array: [...arr.slice(0, leftIndex + rightIndex), ...result, ...left.slice(leftIndex), ...right.slice(rightIndex)],\n        activeIndices: [leftIndex + rightIndex],\n        variables: { leftIndex, rightIndex },\n        description: `${result[result.length - 1]}을 결과 배열에 추가합니다.`\n      });\n    }\n\n    return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n  };\n\n  const mergeSortRecursive = (arr) => {\n    if (arr.length <= 1) return arr;\n\n    const mid = Math.floor(arr.length / 2);\n    const left = arr.slice(0, mid);\n    const right = arr.slice(mid);\n\n    steps.push({\n      array: [...arr],\n      activeIndices: [],\n      variables: { mid },\n      description: `배열을 ${mid} 인덱스를 기준으로 분할합니다.`\n    });\n\n    return merge(mergeSortRecursive(left), mergeSortRecursive(right));\n  };\n\n  const sorted = mergeSortRecursive(arr);\n  arr.splice(0, arr.length, ...sorted);\n\n  steps.push({\n    array: [...arr],\n    activeIndices: [],\n    variables: {},\n    description: '정렬이 완료되었습니다.'\n  });\n\n  return steps;\n};\n\nconst heapSort = (arr) => {\n  const steps = [];\n\n  const heapify = (n, i) => {\n    let largest = i;\n    const left = 2 * i + 1;\n    const right = 2 * i + 2;\n\n    if (left < n && arr[left] > arr[largest]) {\n      largest = left;\n    }\n\n    if (right < n && arr[right] > arr[largest]) {\n      largest = right;\n    }\n\n    if (largest !== i) {\n      steps.push({\n        array: [...arr],\n        activeIndices: [i, largest],\n        variables: { i, largest },\n        description: `arr[${i}]=${arr[i]}와 arr[${largest}]=${arr[largest]}의 위치를 교환합니다.`\n      });\n\n      [arr[i], arr[largest]] = [arr[largest], arr[i]];\n      heapify(n, largest);\n    }\n  };\n\n  const n = arr.length;\n\n  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n    heapify(n, i);\n  }\n\n  for (let i = n - 1; i > 0; i--) {\n    steps.push({\n      array: [...arr],\n      activeIndices: [0, i],\n      variables: { i },\n      description: `루트 노드 arr[0]=${arr[0]}를 마지막 요소 arr[${i}]=${arr[i]}와 교환합니다.`\n    });\n\n    [arr[0], arr[i]] = [arr[i], arr[0]];\n    heapify(i, 0);\n  }\n\n  steps.push({\n    array: [...arr],\n    activeIndices: [],\n    variables: {},\n    description: '정렬이 완료되었습니다.'\n  });\n\n  return steps;\n};\n\nconst quickSort = (arr) => {\n  const steps = [];\n\n  const partition = (low, high) => {\n    const pivot = arr[high];\n    let i = low - 1;\n\n    steps.push({\n      array: [...arr],\n      activeIndices: [high],\n      variables: { pivot, low, high },\n      description: `피벗을 arr[${high}]=${pivot}로 선택합니다.`\n    });\n\n    for (let j = low; j < high; j++) {\n      steps.push({\n        array: [...arr],\n        activeIndices: [j, high],\n        variables: { pivot, i, j },\n        description: `arr[${j}]=${arr[j]}를 피벗 ${pivot}과 비교합니다.`\n      });\n\n      if (arr[j] < pivot) {\n        i++;\n        [arr[i], arr[j]] = [arr[j], arr[i]];\n        steps.push({\n          array: [...arr],\n          activeIndices: [i, j],\n          variables: { pivot, i, j },\n          description: `arr[${i}]=${arr[i]}와 arr[${j}]=${arr[j]}의 위치를 교환합니다.`\n        });\n      }\n    }\n\n    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];\n    steps.push({\n      array: [...arr],\n      activeIndices: [i + 1, high],\n      variables: { pivot, i },\n      description: `피벗을 올바른 위치로 이동합니다.`\n    });\n\n    return i + 1;\n  };\n\n  const quickSortRecursive = (low, high) => {\n    if (low < high) {\n      const pi = partition(low, high);\n      quickSortRecursive(low, pi - 1);\n      quickSortRecursive(pi + 1, high);\n    }\n  };\n\n  quickSortRecursive(0, arr.length - 1);\n\n  steps.push({\n    array: [...arr],\n    activeIndices: [],\n    variables: {},\n    description: '정렬이 완료되었습니다.'\n  });\n\n  return steps;\n};\n\nconst treeSort = (arr) => {\n  const steps = [];\n\n  class Node {\n    constructor(data) {\n      this.data = data;\n      this.left = null;\n      this.right = null;\n    }\n  }\n\n  const insert = (root, key) => {\n    if (root === null) {\n      root = new Node(key);\n      steps.push({\n        array: [...arr],\n        activeIndices: [arr.indexOf(key)],\n        variables: { key },\n        description: `${key}를 트리에 삽입합니다.`\n      });\n      return root;\n    }\n\n    if (key < root.data) {\n      root.left = insert(root.left, key);\n    } else if (key > root.data) {\n      root.right = insert(root.right, key);\n    }\n\n    return root;\n  };\n\n  const inorderTraversal = (root, result) => {\n    if (root !== null) {\n      inorderTraversal(root.left, result);\n      result.push(root.data);\n      steps.push({\n        array: [...result, ...arr.slice(result.length)],\n        activeIndices: [result.length - 1],\n        variables: { current: root.data },\n        description: `${root.data}를 결과 배열에 추가합니다.`\n      });\n      inorderTraversal(root.right, result);\n    }\n  };\n\n  let root = null;\n  for (let i = 0; i < arr.length; i++) {\n    root = insert(root, arr[i]);\n  }\n\n  const sortedArr = [];\n  inorderTraversal(root, sortedArr);\n\n  arr.splice(0, arr.length, ...sortedArr);\n\n  steps.push({\n    array: [...arr],\n    activeIndices: [],\n    variables: {},\n    description: '정렬이 완료되었습니다.'\n  });\n\n  return steps;\n};\n\nconst timSort = (arr) => {\n  const steps = [];\n  const RUN = 32;\n  const n = arr.length;\n\n  const insertionSort = (arr, left, right) => {\n    for (let i = left + 1; i <= right; i++) {\n      const temp = arr[i];\n      let j = i - 1;\n      while (j >= left && arr[j] > temp) {\n        arr[j + 1] = arr[j];\n        j--;\n      }\n      arr[j + 1] = temp;\n      steps.push({\n        array: [...arr],\n        activeIndices: [j + 1],\n        variables: { i, j, temp },\n        description: `${temp}를 ${j + 2}번째 위치에 삽입했습니다.`\n      });\n    }\n  };\n\n  const merge = (arr, l, m, r) => {\n    const len1 = m - l + 1, len2 = r - m;\n    const left = new Array(len1), right = new Array(len2);\n    for (let x = 0; x < len1; x++) {\n      left[x] = arr[l + x];\n    }\n    for (let x = 0; x < len2; x++) {\n      right[x] = arr[m + 1 + x];\n    }\n\n    let i = 0, j = 0, k = l;\n\n    while (i < len1 && j < len2) {\n      if (left[i] <= right[j]) {\n        arr[k] = left[i];\n        i++;\n      } else {\n        arr[k] = right[j];\n        j++;\n      }\n      steps.push({\n        array: [...arr],\n        activeIndices: [k],\n        variables: { i, j, k },\n        description: `${arr[k]}를 ${k + 1}번째 위치에 병합했습니다.`\n      });\n      k++;\n    }\n\n    while (i < len1) {\n      arr[k] = left[i];\n      steps.push({\n        array: [...arr],\n        activeIndices: [k],\n        variables: { i, k },\n        description: `${arr[k]}를 ${k + 1}번째 위치에 병합했습니다.`\n      });\n      i++;\n      k++;\n    }\n\n    while (j < len2) {\n      arr[k] = right[j];\n      steps.push({\n        array: [...arr],\n        activeIndices: [k],\n        variables: { j, k },\n        description: `${arr[k]}를 ${k + 1}번째 위치에 병합했습니다.`\n      });\n      j++;\n      k++;\n    }\n  };\n\n  for (let i = 0; i < n; i += RUN) {\n    insertionSort(arr, i, Math.min((i + RUN - 1), (n - 1)));\n  }\n\n  for (let size = RUN; size < n; size = 2 * size) {\n    for (let start = 0; start < n; start += 2 * size) {\n      const mid = start + size - 1;\n      const end = Math.min((start + 2 * size - 1), (n - 1));\n      merge(arr, start, mid, end);\n    }\n  }\n\n  steps.push({\n    array: [...arr],\n    activeIndices: [],\n    variables: {},\n    description: '정렬이 완료되었습니다.'\n  });\n\n  return steps;\n};\n\nexport default App;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}