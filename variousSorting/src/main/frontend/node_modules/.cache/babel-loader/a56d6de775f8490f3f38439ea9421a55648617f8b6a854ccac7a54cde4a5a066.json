{"ast":null,"code":"// sortingAlgorithms.js\n\nexport const generateSortingSteps = (algorithm, arr) => {\n  const steps = [];\n  const n = arr.length;\n\n  // 초기 상태를 steps에 추가\n  steps.push({\n    array: [...arr],\n    description: '초기 배열',\n    activeIndices: [],\n    variables: {}\n  });\n  switch (algorithm) {\n    case '버블 정렬':\n      for (let i = 0; i < n - 1; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n          if (arr[j] > arr[j + 1]) {\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            steps.push({\n              array: [...arr],\n              description: `${arr[j]}와 ${arr[j + 1]}을 교환`,\n              activeIndices: [j, j + 1],\n              variables: {\n                i,\n                j\n              }\n            });\n          }\n        }\n      }\n      break;\n    case '선택 정렬':\n      for (let i = 0; i < n - 1; i++) {\n        let minIdx = i;\n        for (let j = i + 1; j < n; j++) {\n          if (arr[j] < arr[minIdx]) {\n            minIdx = j;\n          }\n        }\n        if (minIdx !== i) {\n          [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];\n          steps.push({\n            array: [...arr],\n            description: `${arr[i]}와 ${arr[minIdx]}을 교환`,\n            activeIndices: [i, minIdx],\n            variables: {\n              i,\n              minIdx\n            }\n          });\n        }\n      }\n      break;\n    case '삽입 정렬':\n      for (let i = 1; i < n; i++) {\n        let key = arr[i];\n        let j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n          arr[j + 1] = arr[j];\n          j--;\n          steps.push({\n            array: [...arr],\n            description: `${key}를 왼쪽으로 이동`,\n            activeIndices: [j + 1, j + 2],\n            variables: {\n              i,\n              j,\n              key\n            }\n          });\n        }\n        arr[j + 1] = key;\n        steps.push({\n          array: [...arr],\n          description: `${key}를 올바른 위치에 삽입`,\n          activeIndices: [j + 1],\n          variables: {\n            i,\n            j,\n            key\n          }\n        });\n      }\n      break;\n    case '병합 정렬':\n      const merge = (left, right) => {\n        let result = [];\n        let leftIndex = 0;\n        let rightIndex = 0;\n        while (leftIndex < left.length && rightIndex < right.length) {\n          if (left[leftIndex] < right[rightIndex]) {\n            result.push(left[leftIndex]);\n            leftIndex++;\n          } else {\n            result.push(right[rightIndex]);\n            rightIndex++;\n          }\n          steps.push({\n            array: [...result, ...left.slice(leftIndex), ...right.slice(rightIndex)],\n            description: '병합 중',\n            activeIndices: [result.length - 1],\n            variables: {\n              leftIndex,\n              rightIndex\n            }\n          });\n        }\n        return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n      };\n      const mergeSort = arr => {\n        if (arr.length <= 1) return arr;\n        const mid = Math.floor(arr.length / 2);\n        const left = mergeSort(arr.slice(0, mid));\n        const right = mergeSort(arr.slice(mid));\n        return merge(left, right);\n      };\n      arr = mergeSort(arr);\n      break;\n    case '퀵 정렬':\n      const partition = (low, high) => {\n        const pivot = arr[high];\n        let i = low - 1;\n        for (let j = low; j < high; j++) {\n          if (arr[j] < pivot) {\n            i++;\n            [arr[i], arr[j]] = [arr[j], arr[i]];\n            steps.push({\n              array: [...arr],\n              description: `${arr[i]}와 ${arr[j]}를 교환`,\n              activeIndices: [i, j, high],\n              variables: {\n                pivot,\n                i,\n                j\n              }\n            });\n          }\n        }\n        [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];\n        steps.push({\n          array: [...arr],\n          description: `피벗(${pivot})을 올바른 위치로 이동`,\n          activeIndices: [i + 1, high],\n          variables: {\n            pivot,\n            i\n          }\n        });\n        return i + 1;\n      };\n      const quickSort = (low, high) => {\n        if (low < high) {\n          const pi = partition(low, high);\n          quickSort(low, pi - 1);\n          quickSort(pi + 1, high);\n        }\n      };\n      quickSort(0, n - 1);\n      break;\n    case '힙 정렬':\n      const heapify = (n, i) => {\n        let largest = i;\n        const left = 2 * i + 1;\n        const right = 2 * i + 2;\n        if (left < n && arr[left] > arr[largest]) {\n          largest = left;\n        }\n        if (right < n && arr[right] > arr[largest]) {\n          largest = right;\n        }\n        if (largest !== i) {\n          [arr[i], arr[largest]] = [arr[largest], arr[i]];\n          steps.push({\n            array: [...arr],\n            description: `${arr[i]}와 ${arr[largest]}를 교환`,\n            activeIndices: [i, largest],\n            variables: {\n              i,\n              largest\n            }\n          });\n          heapify(n, largest);\n        }\n      };\n      for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n        heapify(n, i);\n      }\n      for (let i = n - 1; i > 0; i--) {\n        [arr[0], arr[i]] = [arr[i], arr[0]];\n        steps.push({\n          array: [...arr],\n          description: `${arr[0]}와 ${arr[i]}를 교환`,\n          activeIndices: [0, i],\n          variables: {\n            i\n          }\n        });\n        heapify(i, 0);\n      }\n      break;\n    case '트리 정렬':\n      class Node {\n        constructor(value) {\n          this.value = value;\n          this.left = null;\n          this.right = null;\n        }\n      }\n      const insert = (node, value) => {\n        if (node === null) {\n          return new Node(value);\n        }\n        if (value < node.value) {\n          node.left = insert(node.left, value);\n        } else {\n          node.right = insert(node.right, value);\n        }\n        return node;\n      };\n      const inorderTraversal = (node, result) => {\n        if (node !== null) {\n          inorderTraversal(node.left, result);\n          result.push(node.value);\n          steps.push({\n            array: [...result, ...arr.filter(x => !result.includes(x))],\n            description: `${node.value}를 결과에 추가`,\n            activeIndices: [result.length - 1],\n            variables: {}\n          });\n          inorderTraversal(node.right, result);\n        }\n      };\n      let root = null;\n      for (const value of arr) {\n        root = insert(root, value);\n      }\n      const result = [];\n      inorderTraversal(root, result);\n      arr = result;\n      break;\n    case '팀 정렬':\n      const MIN_MERGE = 32;\n      const minRunLength = n => {\n        let r = 0;\n        while (n >= MIN_MERGE) {\n          r |= n & 1;\n          n >>= 1;\n        }\n        return n + r;\n      };\n      const insertionSort = (left, right) => {\n        for (let i = left + 1; i <= right; i++) {\n          const temp = arr[i];\n          let j = i - 1;\n          while (j >= left && arr[j] > temp) {\n            arr[j + 1] = arr[j];\n            j--;\n          }\n          arr[j + 1] = temp;\n          steps.push({\n            array: [...arr],\n            description: `${temp}를 올바른 위치에 삽입`,\n            activeIndices: [j + 1, i],\n            variables: {\n              left,\n              right,\n              i,\n              j\n            }\n          });\n        }\n      };\n      const mergeForTimSort = (left, mid, right) => {\n        const leftArray = arr.slice(left, mid + 1);\n        const rightArray = arr.slice(mid + 1, right + 1);\n        let i = 0,\n          j = 0,\n          k = left;\n        while (i < leftArray.length && j < rightArray.length) {\n          if (leftArray[i] <= rightArray[j]) {\n            arr[k] = leftArray[i];\n            i++;\n          } else {\n            arr[k] = rightArray[j];\n            j++;\n          }\n          steps.push({\n            array: [...arr],\n            description: `${arr[k]}를 병합`,\n            activeIndices: [k],\n            variables: {\n              left,\n              mid,\n              right,\n              i,\n              j,\n              k\n            }\n          });\n          k++;\n        }\n        while (i < leftArray.length) {\n          arr[k] = leftArray[i];\n          steps.push({\n            array: [...arr],\n            description: `${arr[k]}를 병합 (왼쪽 배열)`,\n            activeIndices: [k],\n            variables: {\n              left,\n              mid,\n              right,\n              i,\n              j,\n              k\n            }\n          });\n          i++;\n          k++;\n        }\n        while (j < rightArray.length) {\n          arr[k] = rightArray[j];\n          steps.push({\n            array: [...arr],\n            description: `${arr[k]}를 병합 (오른쪽 배열)`,\n            activeIndices: [k],\n            variables: {\n              left,\n              mid,\n              right,\n              i,\n              j,\n              k\n            }\n          });\n          j++;\n          k++;\n        }\n      };\n      const timSort = () => {\n        const minRun = minRunLength(n);\n        for (let i = 0; i < n; i += minRun) {\n          insertionSort(i, Math.min(i + minRun - 1, n - 1));\n        }\n        for (let size = minRun; size < n; size = 2 * size) {\n          for (let start = 0; start < n; start += 2 * size) {\n            const mid = start + size - 1;\n            const end = Math.min(start + 2 * size - 1, n - 1);\n            mergeForTimSort(start, mid, end);\n          }\n        }\n      };\n      timSort();\n      break;\n    default:\n      steps.push({\n        array: [...arr],\n        description: '선택된 알고리즘이 구현되지 않았습니다.',\n        activeIndices: [],\n        variables: {}\n      });\n  }\n  return steps;\n};","map":{"version":3,"names":["generateSortingSteps","algorithm","arr","steps","n","length","push","array","description","activeIndices","variables","i","j","minIdx","key","merge","left","right","result","leftIndex","rightIndex","slice","concat","mergeSort","mid","Math","floor","partition","low","high","pivot","quickSort","pi","heapify","largest","Node","constructor","value","insert","node","inorderTraversal","filter","x","includes","root","MIN_MERGE","minRunLength","r","insertionSort","temp","mergeForTimSort","leftArray","rightArray","k","timSort","minRun","min","size","start","end"],"sources":["/Users/kjunh972/project/jun/Spring/variousSorting/variousSorting/src/main/frontend/src/sortingAlgorithms.js"],"sourcesContent":["// sortingAlgorithms.js\n\nexport const generateSortingSteps = (algorithm, arr) => {\n  const steps = [];\n  const n = arr.length;\n\n  // 초기 상태를 steps에 추가\n  steps.push({\n    array: [...arr],\n    description: '초기 배열',\n    activeIndices: [],\n    variables: {}\n  });\n\n  switch (algorithm) {\n    case '버블 정렬':\n      for (let i = 0; i < n - 1; i++) {\n        for (let j = 0; j < n - i - 1; j++) {\n          if (arr[j] > arr[j + 1]) {\n            [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n            steps.push({\n              array: [...arr],\n              description: `${arr[j]}와 ${arr[j+1]}을 교환`,\n              activeIndices: [j, j + 1],\n              variables: { i, j }\n            });\n          }\n        }\n      }\n      break;\n\n    case '선택 정렬':\n      for (let i = 0; i < n - 1; i++) {\n        let minIdx = i;\n        for (let j = i + 1; j < n; j++) {\n          if (arr[j] < arr[minIdx]) {\n            minIdx = j;\n          }\n        }\n        if (minIdx !== i) {\n          [arr[i], arr[minIdx]] = [arr[minIdx], arr[i]];\n          steps.push({\n            array: [...arr],\n            description: `${arr[i]}와 ${arr[minIdx]}을 교환`,\n            activeIndices: [i, minIdx],\n            variables: { i, minIdx }\n          });\n        }\n      }\n      break;\n\n    case '삽입 정렬':\n      for (let i = 1; i < n; i++) {\n        let key = arr[i];\n        let j = i - 1;\n        while (j >= 0 && arr[j] > key) {\n          arr[j + 1] = arr[j];\n          j--;\n          steps.push({\n            array: [...arr],\n            description: `${key}를 왼쪽으로 이동`,\n            activeIndices: [j + 1, j + 2],\n            variables: { i, j, key }\n          });\n        }\n        arr[j + 1] = key;\n        steps.push({\n          array: [...arr],\n          description: `${key}를 올바른 위치에 삽입`,\n          activeIndices: [j + 1],\n          variables: { i, j, key }\n        });\n      }\n      break;\n\n    case '병합 정렬':\n      const merge = (left, right) => {\n        let result = [];\n        let leftIndex = 0;\n        let rightIndex = 0;\n        while (leftIndex < left.length && rightIndex < right.length) {\n          if (left[leftIndex] < right[rightIndex]) {\n            result.push(left[leftIndex]);\n            leftIndex++;\n          } else {\n            result.push(right[rightIndex]);\n            rightIndex++;\n          }\n          steps.push({\n            array: [...result, ...left.slice(leftIndex), ...right.slice(rightIndex)],\n            description: '병합 중',\n            activeIndices: [result.length - 1],\n            variables: { leftIndex, rightIndex }\n          });\n        }\n        return result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n      };\n\n      const mergeSort = (arr) => {\n        if (arr.length <= 1) return arr;\n        const mid = Math.floor(arr.length / 2);\n        const left = mergeSort(arr.slice(0, mid));\n        const right = mergeSort(arr.slice(mid));\n        return merge(left, right);\n      };\n\n      arr = mergeSort(arr);\n      break;\n\n    case '퀵 정렬':\n      const partition = (low, high) => {\n        const pivot = arr[high];\n        let i = low - 1;\n        for (let j = low; j < high; j++) {\n          if (arr[j] < pivot) {\n            i++;\n            [arr[i], arr[j]] = [arr[j], arr[i]];\n            steps.push({\n              array: [...arr],\n              description: `${arr[i]}와 ${arr[j]}를 교환`,\n              activeIndices: [i, j, high],\n              variables: { pivot, i, j }\n            });\n          }\n        }\n        [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];\n        steps.push({\n          array: [...arr],\n          description: `피벗(${pivot})을 올바른 위치로 이동`,\n          activeIndices: [i + 1, high],\n          variables: { pivot, i }\n        });\n        return i + 1;\n      };\n\n      const quickSort = (low, high) => {\n        if (low < high) {\n          const pi = partition(low, high);\n          quickSort(low, pi - 1);\n          quickSort(pi + 1, high);\n        }\n      };\n\n      quickSort(0, n - 1);\n      break;\n\n    case '힙 정렬':\n      const heapify = (n, i) => {\n        let largest = i;\n        const left = 2 * i + 1;\n        const right = 2 * i + 2;\n\n        if (left < n && arr[left] > arr[largest]) {\n          largest = left;\n        }\n\n        if (right < n && arr[right] > arr[largest]) {\n          largest = right;\n        }\n\n        if (largest !== i) {\n          [arr[i], arr[largest]] = [arr[largest], arr[i]];\n          steps.push({\n            array: [...arr],\n            description: `${arr[i]}와 ${arr[largest]}를 교환`,\n            activeIndices: [i, largest],\n            variables: { i, largest }\n          });\n          heapify(n, largest);\n        }\n      };\n\n      for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {\n        heapify(n, i);\n      }\n\n      for (let i = n - 1; i > 0; i--) {\n        [arr[0], arr[i]] = [arr[i], arr[0]];\n        steps.push({\n          array: [...arr],\n          description: `${arr[0]}와 ${arr[i]}를 교환`,\n          activeIndices: [0, i],\n          variables: { i }\n        });\n        heapify(i, 0);\n      }\n      break;\n\n    case '트리 정렬':\n      class Node {\n        constructor(value) {\n          this.value = value;\n          this.left = null;\n          this.right = null;\n        }\n      }\n\n      const insert = (node, value) => {\n        if (node === null) {\n          return new Node(value);\n        }\n\n        if (value < node.value) {\n          node.left = insert(node.left, value);\n        } else {\n          node.right = insert(node.right, value);\n        }\n\n        return node;\n      };\n\n      const inorderTraversal = (node, result) => {\n        if (node !== null) {\n          inorderTraversal(node.left, result);\n          result.push(node.value);\n          steps.push({\n            array: [...result, ...arr.filter(x => !result.includes(x))],\n            description: `${node.value}를 결과에 추가`,\n            activeIndices: [result.length - 1],\n            variables: {}\n          });\n          inorderTraversal(node.right, result);\n        }\n      };\n\n      let root = null;\n      for (const value of arr) {\n        root = insert(root, value);\n      }\n\n      const result = [];\n      inorderTraversal(root, result);\n      arr = result;\n      break;\n\n    case '팀 정렬':\n      const MIN_MERGE = 32;\n\n      const minRunLength = (n) => {\n        let r = 0;\n        while (n >= MIN_MERGE) {\n          r |= (n & 1);\n          n >>= 1;\n        }\n        return n + r;\n      };\n\n      const insertionSort = (left, right) => {\n        for (let i = left + 1; i <= right; i++) {\n          const temp = arr[i];\n          let j = i - 1;\n          while (j >= left && arr[j] > temp) {\n            arr[j + 1] = arr[j];\n            j--;\n          }\n          arr[j + 1] = temp;\n          steps.push({\n            array: [...arr],\n            description: `${temp}를 올바른 위치에 삽입`,\n            activeIndices: [j + 1, i],\n            variables: { left, right, i, j }\n          });\n        }\n      };\n\n      const mergeForTimSort = (left, mid, right) => {\n        const leftArray = arr.slice(left, mid + 1);\n        const rightArray = arr.slice(mid + 1, right + 1);\n        let i = 0, j = 0, k = left;\n\n        while (i < leftArray.length && j < rightArray.length) {\n          if (leftArray[i] <= rightArray[j]) {\n            arr[k] = leftArray[i];\n            i++;\n          } else {\n            arr[k] = rightArray[j];\n            j++;\n          }\n          steps.push({\n            array: [...arr],\n            description: `${arr[k]}를 병합`,\n            activeIndices: [k],\n            variables: { left, mid, right, i, j, k }\n          });\n          k++;\n        }\n\n        while (i < leftArray.length) {\n          arr[k] = leftArray[i];\n          steps.push({\n            array: [...arr],\n            description: `${arr[k]}를 병합 (왼쪽 배열)`,\n            activeIndices: [k],\n            variables: { left, mid, right, i, j, k }\n          });\n          i++;\n          k++;\n        }\n\n        while (j < rightArray.length) {\n          arr[k] = rightArray[j];\n          steps.push({\n            array: [...arr],\n            description: `${arr[k]}를 병합 (오른쪽 배열)`,\n            activeIndices: [k],\n            variables: { left, mid, right, i, j, k }\n          });\n          j++;\n          k++;\n        }\n      };\n\n      const timSort = () => {\n        const minRun = minRunLength(n);\n\n        for (let i = 0; i < n; i += minRun) {\n          insertionSort(i, Math.min(i + minRun - 1, n - 1));\n        }\n\n        for (let size = minRun; size < n; size = 2 * size) {\n          for (let start = 0; start < n; start += 2 * size) {\n            const mid = start + size - 1;\n            const end = Math.min(start + 2 * size - 1, n - 1);\n            mergeForTimSort(start, mid, end);\n          }\n        }\n      };\n\n      timSort();\n      break;\n\n    default:\n      steps.push({\n        array: [...arr],\n        description: '선택된 알고리즘이 구현되지 않았습니다.',\n        activeIndices: [],\n        variables: {}\n      });\n  }\n\n  return steps;\n};"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}