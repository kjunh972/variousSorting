{"ast":null,"code":"import axios from 'axios';\nconst API_BASE_URL = 'http://localhost:8080/api/sort';\nexport const generateSortingSteps = async (algorithm, arr) => {\n  try {\n    const response = await axios.post(`${API_BASE_URL}/${algorithm}`, arr);\n    return response.data;\n  } catch (error) {\n    console.error('Error generating sorting steps:', error);\n    return [];\n  }\n};\nexport const algorithmOptions = ['선택 정렬', '삽입 정렬', '버블 정렬', '병합 정렬', '힙 정렬', '퀵 정렬', '트리 정렬', '팀 정렬'];\nexport const SortingSteps = {\n  '선택 정렬': \"배열을 순회하면서 가장 작은 원소를 찾아 맨 앞으로 이동시키는 방식으로 정렬합니다.\",\n  '삽입 정렬': \"배열의 각 원소를 이미 정렬된 부분 배열의 적절한 위치에 삽입하여 정렬합니다.\",\n  '버블 정렬': \"인접한 두 원소를 비교하여 큰 값을 뒤로 보내는 과정을 반복하여 정렬합니다.\",\n  '병합 정렬': \"배열을 반으로 나누고, 각 부분을 정렬한 후 병합하는 과정을 재귀적으로 수행합니다.\",\n  '힙 정렬': \"배열을 최대 힙으로 구성한 후, 루트 노드와 마지막 노드를 교환하며 정렬합니다.\",\n  '퀵 정렬': \"피벗을 선택하고 피벗보다 작은 값과 큰 값을 분할한 후, 각 부분을 재귀적으로 정렬합니다.\",\n  '트리 정렬': \"이진 탐색 트리를 구성한 후, 중위 순회하여 정렬된 결과를 얻습니다.\",\n  '팀 정렬': \"삽입 정렬과 병합 정렬을 조합하여 효율적으로 정렬합니다.\"\n};\nexport const variableDescriptions = {\n  i: \"현재 기준 인덱스\",\n  j: \"비교 대상 인덱스\",\n  key: \"삽입할 현재 값\",\n  minIdx: \"현재까지의 최소값 인덱스\",\n  pivot: \"퀵정렬의 기준값\",\n  left: \"왼쪽 포인터\",\n  right: \"오른쪽 포인터\",\n  mid: \"중간 인덱스\",\n  temp: \"임시 저장 변수\"\n};","map":{"version":3,"names":["axios","API_BASE_URL","generateSortingSteps","algorithm","arr","response","post","data","error","console","algorithmOptions","SortingSteps","variableDescriptions","i","j","key","minIdx","pivot","left","right","mid","temp"],"sources":["/Users/kjunh972/project/jun/Spring/variousSorting/variousSorting/src/main/frontend/src/SortingAlgorithms.js"],"sourcesContent":["import axios from 'axios';\n\nconst API_BASE_URL = 'http://localhost:8080/api/sort';\n\nexport const generateSortingSteps = async (algorithm, arr) => {\n  try {\n    const response = await axios.post(`${API_BASE_URL}/${algorithm}`, arr);\n    return response.data;\n  } catch (error) {\n    console.error('Error generating sorting steps:', error);\n    return [];\n  }\n};\n\nexport const algorithmOptions = [\n  '선택 정렬', '삽입 정렬', '버블 정렬', '병합 정렬',\n  '힙 정렬', '퀵 정렬', '트리 정렬', '팀 정렬'\n];\n\nexport const SortingSteps = {\n  '선택 정렬': \"배열을 순회하면서 가장 작은 원소를 찾아 맨 앞으로 이동시키는 방식으로 정렬합니다.\",\n  '삽입 정렬': \"배열의 각 원소를 이미 정렬된 부분 배열의 적절한 위치에 삽입하여 정렬합니다.\",\n  '버블 정렬': \"인접한 두 원소를 비교하여 큰 값을 뒤로 보내는 과정을 반복하여 정렬합니다.\",\n  '병합 정렬': \"배열을 반으로 나누고, 각 부분을 정렬한 후 병합하는 과정을 재귀적으로 수행합니다.\",\n  '힙 정렬': \"배열을 최대 힙으로 구성한 후, 루트 노드와 마지막 노드를 교환하며 정렬합니다.\",\n  '퀵 정렬': \"피벗을 선택하고 피벗보다 작은 값과 큰 값을 분할한 후, 각 부분을 재귀적으로 정렬합니다.\",\n  '트리 정렬': \"이진 탐색 트리를 구성한 후, 중위 순회하여 정렬된 결과를 얻습니다.\",\n  '팀 정렬': \"삽입 정렬과 병합 정렬을 조합하여 효율적으로 정렬합니다.\"\n};\n\nexport const variableDescriptions = {\n  i: \"현재 기준 인덱스\",\n  j: \"비교 대상 인덱스\",\n  key: \"삽입할 현재 값\",\n  minIdx: \"현재까지의 최소값 인덱스\",\n  pivot: \"퀵정렬의 기준값\",\n  left: \"왼쪽 포인터\",\n  right: \"오른쪽 포인터\",\n  mid: \"중간 인덱스\",\n  temp: \"임시 저장 변수\"\n};"],"mappings":"AAAA,OAAOA,KAAK,MAAM,OAAO;AAEzB,MAAMC,YAAY,GAAG,gCAAgC;AAErD,OAAO,MAAMC,oBAAoB,GAAG,MAAAA,CAAOC,SAAS,EAAEC,GAAG,KAAK;EAC5D,IAAI;IACF,MAAMC,QAAQ,GAAG,MAAML,KAAK,CAACM,IAAI,CAAC,GAAGL,YAAY,IAAIE,SAAS,EAAE,EAAEC,GAAG,CAAC;IACtE,OAAOC,QAAQ,CAACE,IAAI;EACtB,CAAC,CAAC,OAAOC,KAAK,EAAE;IACdC,OAAO,CAACD,KAAK,CAAC,iCAAiC,EAAEA,KAAK,CAAC;IACvD,OAAO,EAAE;EACX;AACF,CAAC;AAED,OAAO,MAAME,gBAAgB,GAAG,CAC9B,OAAO,EAAE,OAAO,EAAE,OAAO,EAAE,OAAO,EAClC,MAAM,EAAE,MAAM,EAAE,OAAO,EAAE,MAAM,CAChC;AAED,OAAO,MAAMC,qBAAqB,GAAG;EACnC,OAAO,EAAE,gDAAgD;EACzD,OAAO,EAAE,6CAA6C;EACtD,OAAO,EAAE,4CAA4C;EACrD,OAAO,EAAE,gDAAgD;EACzD,MAAM,EAAE,8CAA8C;EACtD,MAAM,EAAE,oDAAoD;EAC5D,OAAO,EAAE,wCAAwC;EACjD,MAAM,EAAE;AACV,CAAC;AAED,OAAO,MAAMC,oBAAoB,GAAG;EAClCC,CAAC,EAAE,WAAW;EACdC,CAAC,EAAE,WAAW;EACdC,GAAG,EAAE,UAAU;EACfC,MAAM,EAAE,eAAe;EACvBC,KAAK,EAAE,UAAU;EACjBC,IAAI,EAAE,QAAQ;EACdC,KAAK,EAAE,SAAS;EAChBC,GAAG,EAAE,QAAQ;EACbC,IAAI,EAAE;AACR,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}